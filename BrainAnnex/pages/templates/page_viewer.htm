<!DOCTYPE html>
{#  General viewer page for a list of Content Items (the list is specified in Flask parameter content_items)
    Vue.js is used for the rendering

    Flask-passed parameters:

        site_pages
        current_page
        header_title

        category_uri        A string with the URI of the Category featured on this page
        category_name       The name of the above Category
        category_remarks    Descriptive extra text about this Category (may be missing)

        all_categories      A list of dicts.  Note that the 'remarks' and 'pinned' keys may or may not be present.
                                    EXAMPLE:
                                          [{"uri": 1,   "name": "HOME", "remarks": "ROOT NODE"},
                                           {"uri: 123,  "name": "Calculus"},
                                           {"uri": 523, "name": "Work at Acme", "pinned": True}]
        subcategories       EXAMPLE: [{'uri': '2', 'name': 'Work', remarks: 'outside employment', OTHER_FIELDS_NOT_USED}]
        parent_categories
        siblings_categories

        bread_crumbs    A list with data from which to create UI "bread crumbs"

        see_also_links  A list with data about all the "see also" links originating from this Category
                            EXAMPLE:  [{'name': 'Quotes', 'uri': '823', 'description': None}]

        records_types   A list of all the Classes that can be used for new Records
                            (i.e. classes that are INSTANCE_OF the "Records" class)
                            EXAMPLE: ["Cuisine Type","Entrees","French Vocabulary","German Vocabulary","Restaurants","Site Link"]
                            Used for the addition of new records
                            (TODO: maybe obtain thru a server call, when first needed)

        records_schema_data: A dictionary of record class names, mapped into the ordered list of their property names.
                             Note that properties that have the attribute "system" set to True, are excluded
                             EXAMPLE:
                             {"Quotes": ["quote", "attribution", "notes"],
                              "French Vocabulary": ["French", "English", "notes"],
                              "Site Link": ["url", "name", "date", "comments", "rating", "read"]
                             }

        content_items:  A list of dictionaries
                        EXAMPLE:
                        [{'schema_code': 'i', 'uri': 1,'width': 450, 'basename': 'my_pic', 'suffix': 'PNG', pos: 0, 'class_name': 'Images'},
                         {'schema_code': 'h', 'uri': 1, 'text': 'Overview', pos: 10, 'class_name': 'Headers'},
                         {'schema_code': 'n', 'uri': 1', basename': 'overview', 'suffix': 'htm', pos: 20, 'class_name': 'Notes'}
                        ]

    ----------------------------------------------------------------------------------
    MIT License.  Copyright (c) 2021-2024 Julian A. West
	----------------------------------------------------------------------------------
 #}


<html lang="en">
<head>
    <title>BA-{{category_name}}</title>

    <!-- General and module styling -->
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/css/brain_annex.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/css/page_viewer.css">

    <link type="text/css" rel="stylesheet" href="/navigation/static/horiz_status_bar.css">
    <link type="text/css" rel="stylesheet" href="/navigation/static/navbar_top.css">

    <link type="text/css" rel="stylesheet" href="/BA/pages/static/modules/dropzone/dropzone.css">

    <!-- Styling for Vue CORE components -->
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/bread_crumbs/bread_crumbs.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/toc_sidebar/toc_sidebar.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/category_navbox/category_navbox.css">

    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/content_items/content_items.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/controls/controls.css">
    
    <!-- PLUGIN-specific styling -->
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/PLUGINS/headers/headers.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/PLUGINS/images/images.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/PLUGINS/documents/documents.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/PLUGINS/notes/notes.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/PLUGINS/codedocs/codedocs.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/PLUGINS/site_link/site_link.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/PLUGINS/records/records.css">

    <!-- JavaScript -->
    <script src="/BA/pages/static/Vue2/vue2.js"></script>   <!-- Vue.js (version 2) -->
    <script src="/BA/pages/static/modules/CKeditor/ckeditor.js"></script>
    <script src="/BA/pages/static/modules/dropzone/dropzone.js"></script>
    <script src="/BA/api/static/server_communication.js"></script>
</head>


<body>


<div id="vue-root">   <!-- Container for VUE COMPONENTS : the ROOT of the components below -->


{# HORIZONTAL STATUS BAR (fixed at the top) #}
{% include "horiz_status_bar.htm" %}



<!--   The "scroll-canvas" is the MAIN part of the page,
       incl. the navbar at the top and the sidebox on the right,
       but exclusive of the left sidebar, which is fixed in position -->
<div v-bind:class="{ 'scroll-canvas': show_left_sidebar, 'scroll-canvas--collapsed-left': !show_left_sidebar }">



{# TOP NAVIGATION BAR (scrolls with main part of page) #}
{% include "navbar_top.htm" %}




<!-- ****************************************************************

                LEFT side-bar (used for Table of Contents)

     **************************************************************** -->

<vue-toc-sidebar
    v-bind:content_array="content_array"
    v-bind:show_left_sidebar="show_left_sidebar"

    v-on:adjust-left-sidebar="adjust_left_sidebar($event)"
>
</vue-toc-sidebar>



<!-- ****************************************************************

               RIGHT side-box (with Category navigation)

 **************************************************************** -->

<vue-category-navbox
    v-bind:category_name="category_name"
    v-bind:current_category_uri="category_uri"
    v-bind:parent_categories="parent_categories"
    v-bind:subcategories="all_subcategories"
    v-bind:siblings_categories="siblings_categories"
    v-bind:all_categories="all_categories"
    v-bind:show_right_sidebox="show_right_sidebox"

    v-on:adjust-right-sidebox="adjust_right_sidebox($event)"
>
</vue-category-navbox>





<div v-bind:class="{ 'lightbox': show_right_sidebox, 'lightbox--expand-right': !show_right_sidebox }">


<!-- ****************************************************************

                        TOP OF PAGE

 **************************************************************** -->

{#  Uncomment for DEBUGGING! (to view some of the Flask-passed parameters)
    <br><b>siblings_categories</b>:<br>{{siblings_categories}}<br><br>
    <br><b>all_categories</b>:<br>{{all_categories}}<br><br>
 #}



<!-- Bread crumbs for this Category -->
<vue-bread-crumbs
    v-bind:category_uri="category_uri"
    v-bind:bread_crumbs="bread_crumbs"
    v-bind:all_categories="all_categories"
>
</vue-bread-crumbs>



{# Display prominently this page's Category #}
{% if category_name %}
<p class="headline">
    {{category_name}}
    <span style="color:gray; margin-left:25px; font-size:10px">{{category_remarks}}</span>
    {# Category management #}
    <a v-if="expose_controls"  href="/BA/pages/category_manager/{{category_uri}}"  target="_blank"  style="margin-left:15px">
        <img src='/BA/pages/static/graphics/edit_16_2530834.png' alt='EDIT category (rename, etc.)' title='EDIT category (rename, etc.)'>
    </a>
    <a v-if="expose_controls"  @click="bulk_operations = !bulk_operations"  class="clickable-icon"  style='margin-left:20px'>
        <img src='/BA/pages/static/graphics/bulk_operation_16_1031512.png'
             alt='Toggle BULK operations (tag, move, delete)' title='Toggle BULK operations (tag, move, delete)'>
    </a>
</p>
{% endif %}


{# Display all subcategories (at the top) #}
<div v-if="all_subcategories.length > 0" class='subsections'>
    <span class='subsections-label'>Subcategories: </span>
    <template v-for="(subcategory, index) in all_subcategories" class='subsection-link'>
        <span v-if="index == 0" class='subsection-link'><a v-bind:href="'/BA/pages/viewer/' + [[ subcategory['uri'] ]]">[[ subcategory['name'] ]]</a></span>
        <span v-else class='subsection-link'>&nbsp; &diams; &nbsp;<a v-bind:href="'/BA/pages/viewer/' + [[ subcategory['uri'] ]]">[[ subcategory['name'] ]]</a></span>
    </template>
</div>



{# Display the "SEE ALSO" links, if present #}
{% if see_also_links != [] %}
    <p style="margin-bottom:15px">
        -> <b>SEE ALSO:</b>&nbsp;&nbsp;&nbsp;
        {% for my_item in see_also_links %}
            <a href="/BA/pages/viewer/{{my_item.uri}}" style="margin-right:30px">
                {{my_item.description  if my_item.description != None  else my_item.name}}
            </a>
        {% endfor %}
    </p>
{% endif %}



{# Give notice if no Content Items were passed #}
<p v-if="is_page_empty" style="margin-top:50px; color:#888">
    NO CONTENT ITEMS FOUND : you need to add or upload them
</p>





<!-- ****************************************************************

                        MAIN LOOP of Content Items

 **************************************************************** -->

<!-- Depending on whether the EDITING CONTROLS are shown or hidden,
     one of the following 2 blocks gets shown
  -->


<!-- (PART 1 of 2)

     Original version, to be used when the EDITING CONTROLS are SHOWN.
     This version separates all the Content Items into individual entities.

     For each Content Item on this page, make use of the appropriate Vue component (picked dynamically).
     Handle here some UI operations common to all types, such as moves around the page.
     Type-specific operations, such as editing, are handled by the individual components

     v-bind:key Used to provide unique identifiers for each Vue component (it may change if content_array changes)
     v-bind:is  Specifies which component to use, based on the type of the Content Item

     Props (arguments) passed to the components [some are meant for the 'vue-controls' sub-components]
            v-bind:item="item"
            v-bind:expose_controls="expose_controls"
            v-bind:category_uri="category_uri"
            v-bind:index="index"                        Zero-based position of the Content Item on the page
            v-bind:item_count="content_array.length"

            v-bind:records_types="records_types"

            v-bind:schema_data="get_schema_data(item)"  Only used for Content Items of type Record (schema_code "r"). A list of field names, in order.
                                                        EXAMPLE: ["French", "English", "notes"]

     Intercept various SIGNALS from descendant components:
        Originating in grandchildren:
            v-on:delete-content-item
            v-on:move-up-content-item
            v-on:move-down-content-item
        Originating in children:
            v-on:cancel-edit
            v-on:updated-item
            v-on:insert-new-item
     -->

<template v-if="expose_controls && !bulk_operations"  v-for="(item, index) in content_array">

    <vue-content-items
        v-bind:key="item.schema_code + '_' + item.uri + '_' + index"

        v-bind:item="item"
        v-bind:expose_controls="expose_controls"
        v-bind:category_uri="category_uri"
        v-bind:index="index"
        v-bind:item_count="content_array.length"

        v-bind:registered_plugins = "registered_plugins"
        v-bind:records_types="records_types"

        v-bind:schema_data="get_schema_data(item)"
        v-bind:all_categories="all_categories"

        v-on:delete-content-item-highlighted="delete_content_item(item)"
        v-on:move-up-content-item="move_up_content_item(item)"  v-on:move-down-content-item="move_down_content_item(item)"
        v-on:relocate-content-item="relocate_content_item(item, $event)"
        v-on:cancel-edit="cancel_edit(item)"
        v-on:updated-item="absorb_item_updates(item, $event)"
        v-on:insert-new-item="insert_new_item_after(item, $event)"
    >
    </vue-content-items>

</template>




<!-- For BULK OPERATIONS -->

<template v-if="bulk_operations"  v-for="(item, index) in content_array">

    <vue-content-items
            v-bind:key="item.uri"

            v-bind:item="item"
            v-bind:expose_controls="false"
            v-bind:category_uri="category_uri"
            v-bind:index="index"
            v-bind:item_count="content_array.length"

            v-bind:registered_plugins = "registered_plugins"
            v-bind:records_types="records_types"

            v-bind:schema_data="get_schema_data(item)"
            v-bind:all_categories="all_categories"
    >
    </vue-content-items>

    <p style="margin-top:0; margin-bottom:40px">
        <input type="checkbox"  v-bind:ref="item.uri"  @click="bulk_checkbox_clicked(item.uri)">
    </p>

</template>


<template v-if="bulk_operations">
    <p style="margin-left:15px; font-style:italic">
        Move the selected items to a new category:
    </p>

    <button @click="perform_bulk_operation"
        style="margin-left:15px; margin-right:15px; margin-bottom:30px; padding:20px; font-size:24px; font-weight:bold; border:1px solid #660000; background-color:#00cc00; color:#fff; border-radius:15px">
        BULK RE-CLASSIFY
    </button>

    <span style="font-style:bold; font-size:18px">AS...</span>

    <select v-model="category_to_move_to"
            v-bind:title="'Reclassify the selected Content Items with a different Category tag'"
            style='margin-left:15px'>
        <option disabled value="">[Select new tag]</option>
        <option v-for="cat in all_categories"
                v-if="cat.uri != category_uri"
                v-bind:value="{uri: cat.uri , name: cat.name}">
            [[cat.name]]
        </option>
    </select>

    <br>
    <span v-if="waiting" class="waiting">Performing the bulk operation...</span>
    <span v-bind:class="{'error-message': error, 'status-message': !error }">[[status_message]]</span>
    <br><br>
</template>




<!-- (PART 2 of 2)

    New version, to be used when the EDITING CONTROLS are HIDDEN (i.e. in viewing mode.)
    This version groups together similar adjacent records
  -->

<template v-if="!expose_controls"  v-for="group in element_grouping">

    <!-- If it's "UN-grouped", show it here as an INDIVIDUAL Content Item-->
    <vue-content-items  v-if="!group.use_group"
            v-bind:key="content_array[group.index].schema_code + '_' + content_array[group.index].uri + '_' + group.index + '_bis'"

            v-bind:item="content_array[group.index]"
            v-bind:expose_controls="expose_controls"
            v-bind:category_uri="category_uri"
            v-bind:index="group.index"
            v-bind:item_count="content_array.length"

            v-bind:registered_plugins = "registered_plugins"
            v-bind:records_types="records_types"

            v-bind:schema_data="get_schema_data(content_array[group.index])"

            v-on:delete-content-item-highlighted="delete_content_item(content_array[group.index])"
            v-on:move-up-content-item="move_up_content_item(content_array[group.index])"  v-on:move-down-content-item="move_down_content_item(content_array[group.index])"
            v-on:relocate-content-item="relocate_content_item(content_array[group.index], $event)"
            v-on:cancel-edit="cancel_edit(content_array[group.index])"
            v-on:updated-item="absorb_item_updates(content_array[group.index], $event)"
            v-on:insert-new-item="insert_new_item_after(content_array[group.index], $event)"
    >
    </vue-content-items>


    <!-- If it's "grouped", show the WHOLE GROUP of records here -->
    <vue-plugin-table v-if="group.use_group"
                      v-bind:key="group.index"

                      v-bind:record_data_list="content_array.slice(group.index, group.index + group.group_size)"
                      v-bind:common_fields="group.fields"

                      v-on:updated-item="absorb_item_updates_REVISED($event)"
    ></vue-plugin-table>

</template>







<a name="BOTTOM"></a>   <!-- Anchor for page scrolling to the bottom of the page-->


<br><br>


<div v-show="expose_controls && !bulk_operations">

    <h3>Add at the bottom of page</h3>
    <span style="margin-right:10px">Add new:</span>
    <button @click="add_new_item_at_bottom('h')" style="margin-right:10px">Header</button>
    <button @click="add_new_item_at_bottom('n')" style="margin-right:10px">Note</button>
    <button @click="add_new_item_at_bottom('sl', 'Site Link')" style="margin-right:10px">Site Link (Bookmark)</button>
    <button @click="add_new_item_at_bottom('cd')" style="margin-right:10px">Code Documentation</button>

    <!-- Show all leaf Classes that are direct instances of "Records" -->
    <br>Add new record of type:
    {% for class_name in records_types %}
        <button @click='add_new_item_at_bottom("r", "{{class_name}}")'
                class="record-picker"
                style="color: {% if (loop.index % 7) == 1 %}#ae9cd6{% elif (loop.index % 7) == 2 %}#8bb9d4{% elif (loop.index % 7) == 3 %}#a6cfa1{% elif (loop.index % 7) == 4 %}#dad6a1{% elif (loop.index % 7) == 5 %}#e1b298{% elif (loop.index % 7) == 6 %}#e59ca0{% elif (loop.index % 7) == 0 %}gray{% else %}black{% endif %}">
            {{class_name}}
        </button>
    {% endfor %}

    <br>


    <div style='border:1px solid gray; padding:10px; background-color:#DDDDDD; margin-top:5px; margin-bottom:5px; margin-right:5px'>		<!-- Maybe the DIV wrapper could be ditched? -->

        <b>UPLOAD IMAGES or DOCUMENTS</b>:<br>

        <form action='/BA/api/upload_media' class='dropzone' id='myDropzone_d' style='padding-top:5px; margin-bottom:8px'>
            <input type='hidden' name='category_id' value='{{category_uri}}'>
            <input type='hidden' name='pos' value='TBA_insert_after_JUST_ADDING_AT_END_FOR_NOW'>
        </form>

        <!--  The "DONE" button simply reloads the viewer page -->
        <a href='' style='font-size:18px; border:1px solid #660000; background-color:#00cc00; text-decoration:none; color:#fff; border-radius:5px; padding:4px'>Close</a>
        <span style='color:gray; margin-left:20px; font-size:10px'>The "Close" button not yet implemented: currently, it refreshes the page (use when uploads complete)</span><br>

    </div>	<!--  Terminate the wrapper DIV for uploads -->





    <!--  To add a new Subcategory (TODO: turn into a Vue component) -->
    <div style='clear: left;'></div> {# To clear any Content Item #}

    <div class='form-box' style="float:right">
        <span class='title'>CREATE A NEW SUBCATEGORY for &ldquo;{{category_name}}&rdquo;</span><br><br>

        <input type='hidden' name='parentID' value={{category_uri}}>

        <table border='0' cellspacing='5' cellpadding='0'>
            <tr>
                <td>Name</td>
                <td style='padding-left:5px'><input type='text' v-model="new_subcategory_name" size='50' maxlength='60'></td>
            </tr>
            <tr>
                <td>Remarks <span style='color:gray; font-style:italic'>(optional)</span></td>
                <td style='padding-left:5px'><input type='text'  v-model="new_subcategory_remarks" size='50' maxlength='90'></td>
            </tr>
        </table>

        <br>
        <button @click="add_subcategory">Add New Sub-Category</button>
            <span v-if="waiting" class="waiting">Adding the subcategory...</span>
            <span v-bind:class="{'error-message': error, 'status-message': !error }">[[status_message]]</span>
        <br><br>
        <span style='color:gray'><b>OR:</b> add an <a href='/BA/pages/category_manager/{{category_uri}}'><i>existing</i></a> sub-category</span>
    </div>






    <div style='height:170px'></div>     <!-- To extend the main page enough to fit the above floating element -->
    <br><br>

</div>




</div>  <!-- END OF lightbox -->




<!-- Icons (in fixed positions) to expose/hide the editing controls -->
<img v-if="!expose_controls" @click="expose_controls = true"
     class="clickable-icon  fixed-2nd-from-bottom"
     alt="SHOW the Editing Controls (un-lock the page)" title="SHOW the Editing Controls (un-lock the page)"
     src="/BA/pages/static/graphics/screwdriver_unlock.png" width="40" height="40">

<img v-if="expose_controls" @click="expose_controls = false"
     class="clickable-icon  fixed-2nd-from-bottom"
     alt="HIDE the Editing Controls (lock the page)" title="HIDE the Editing Controls (lock the page)"
     src="/BA/pages/static/graphics/lock_6611478_64.png" width="40" height="40">


<!-- Icon (in fixed position) to scroll to top of page -->
<a id="to_top" href="javascript:;" onclick="window.scrollTo(0, 0)">
    <img src="/BA/pages/static/graphics/to_top_80.png" width="40" height="40"
         alt="Scroll to TOP of page" title="Scroll to TOP of page">
</a>


<br>
<div v-if="expose_controls">
    <a href="/BA/pages/md-file/{{category_uri}}" target="_blank">Export to MD file</a>
    <a href="/BA/pages/static-web/{{category_uri}}" target="_blank" style="margin-left:50px">Export to static webpage</a>
</div>
<br><br>



</div>  <!-- END OF scroll-canvas -->

</div>	<!--  ~~~~~~~~~~~~~~~~~~~~~  END of Vue root element  ~~~~~~~~~~~~~~~~~~~~~  -->





<!--
    Vue components (and other JS).  This must appear AFTER the Vue-containing elements
  -->
<script src="/BA/pages/static/vue_components/bread_crumbs/bread_crumbs.js"></script>
<script src="/BA/pages/static/vue_components/toc_sidebar/toc_sidebar.js"></script>
<script src="/BA/pages/static/vue_components/category_navbox/category_navbox.js"></script>

<script src="/BA/pages/static/vue_components/content_items/content_items.js"></script>
<script src="/BA/pages/static/vue_components/controls/controls.js"></script>

<script src="/BA/pages/static/modules/vue-clipboard2/vue-clipboard.js"></script>


<!-- PLUGIN-specific Vue components -->
<script src="/BA/pages/static/vue_components/PLUGINS/headers/headers.js"></script>
<script src="/BA/pages/static/vue_components/PLUGINS/images/images.js"></script>
<script src="/BA/pages/static/vue_components/PLUGINS/documents/documents.js"></script>
<script src="/BA/pages/static/vue_components/PLUGINS/notes/notes.js"></script>
<script src="/BA/pages/static/vue_components/PLUGINS/codedocs/codedocs.js"></script>
<script src="/BA/pages/static/vue_components/PLUGINS/site_link/site_link.js"></script>

<script src="/BA/pages/static/vue_components/PLUGINS/records/records.js"></script>
<script src="/BA/pages/static/vue_components/PLUGINS/records/records_linked.js"></script>
<script src="/BA/pages/static/vue_components/PLUGINS/records/single_record.js"></script>
<script src="/BA/pages/static/vue_components/PLUGINS/records/table.js"></script>



<script>
// Instantiation of the ROOT component must come after the definition of the descendant components
new Vue({
    el: '#vue-root',

    delimiters: ['[[', ']]'] ,  // Changing delimiters: requesting double SQUARE brackets, to avoid interfering with Flask



    // ---------------------  DATA  ----------------------

    data: {     // GLOBAL DATA for the whole page (Vue root element).
                // This is the handover of data from Flask to Vue

        registered_plugins: ["n", "i", "h", "cd", "d", "sl"],  // "r" not included here, because a generic core one
                                                               // TODO: either pass from the database, or infer from some config file
                                                               // IMPORTANT: the items in the list MUST correspond to the folders in
                                                               //      BrainAnnex/pages/static/vue_components/PLUGINS

        content_array: {{content_items | tojson(indent=4)}},
                                    // Array containing objects with the data for all the Content Items on the page
                                    // EXAMPLE: [{pos:0,"uri":5,schema_code:"h",text:"GENERAL METHODS", class_name: "Headers"},
                                    //           {pos:50,"uri":8,schema_code:"i",basename:"mypix",suffix:"png", class_name: "Images"}
                                    //          ]
                                    // TODO: component-editable fields and non-editable ones ("pos", "uri", "schema_code", "class_name") ought to be treated differently

        expose_controls: false,     // If true, the editing controls of the various Content Items are revealed

        category_uri: {{category_uri | tojson}},   // A string with the URI of the Category featured on this page

        show_left_sidebar: true,        // Indicating whether to show or collapse the left sidebar (with the Page Contents)
        show_right_sidebox: true,       // Indicating whether to show or collapse the right sidebox (with the Category navigation)

        records_types: {{records_types | tojson}},    // Array of all the names of leaf Classes associated to records

        records_schema_data : {{records_schema_data | tojson }}, // EXAMPLE:
                                                                 // {"Quotes": ["quote", "attribution", "notes"],
                                                                 //  "French Vocabulary": ["French", "English", "notes"],
                                                                 //  "Site Link": ["url", "name", "date", "comments", "rating", "read"]}

        bread_crumbs: {{bread_crumbs | tojson}},
                        // EXAMPLE: ["START_CONTAINER", [1, 544, 514], "END_CONTAINER"]

        category_name: {{category_name | tojson}},

        parent_categories: {{parent_categories  | tojson}},

        all_subcategories: {{subcategories | tojson}},
                        // EXAMPLE: [{"uri":"709","name":"English"},{"uri":"708","name":"Italian"},{"uri":"514","name":"French"}]

        siblings_categories: {{siblings_categories | tojson}},
                        // EXAMPLE: [{'name': 'French', 'uri': 514, 'schema_code': 'cat', 'internal_id': 522}]

        all_categories: {{all_categories | tojson}},
                        // EXAMPLE: [{"uri": 1, "name": "HOME", "remarks": "ROOT NODE"}, {"uri": 523, "name": "work", 'pinned': True}]


        // For bulk operations
        bulk_operations: false,     // If true, checkboxes for bulk operations of Content Items are revealed
        checkboxes_selected: [],    // Array of strings, containing the URI's of the Content Items selected for bulk operations
        category_to_move_to: null,


        // For the "Add Subcategory" form (TODO: move to a separate component?)
        new_subcategory_name: "",
        new_subcategory_remarks: "",
        status_message: "",          // Message for the user about the status of the last operation (NOT used for "waiting" status)
        error: false,                // Whether the last server communication resulted in error
        waiting: false               // Whether any server request is still pending

    }, // DATA



    // ---------------------  HOOKS  ----------------------

    mounted() {
        // If the page is devoid of content and of sub-categories, switch automatically to editing mode
        if (this.is_page_empty)
            this.expose_controls = true;
    },



    // ---------------------  COMPUTED  ----------------------

    computed: {
        is_page_empty()
        // Return true if the page is empty of content and of sub-categories; false, otherwise
        {
            if (this.content_array.length == 0 && this.all_subcategories.length == 0)
                return true;
            else
                return false;
        },


        element_grouping()
        /*  A list of "lumped" records, and other "singleton" Content Items, on the page
            EXAMPLE:
                [{index:0, group_size: 2, use_group: true, fields: ["German", "English"]},
                 {index:2, group_size: 1, use_group: true, fields: ["German", "English", "notes"]},
                 {index:3, group_size: 1, use_group: false},
                 {index:4, group_size: 1, use_group: false}
                ]
         */
        {
            return this.build_groupings();
        }

    }, // COMPUTED



    // ----------------------------  METHODS  -----------------------------

    methods:  {

        bulk_checkbox_clicked(uri)
        // Invoked whenever the user clicks on any of the bulk-edit checkboxes
        {
            console.log(`Clicked checkbox for Content Item with URI: '${uri}'`);

            //console.log(this.$refs);                // Shows an array
            const checkbox_element = this.$refs[uri]; // Pluck out the specific checkbox HTML element that invoked this function
            //console.log(checkbox_element);          // Somehow, this reveals an array with 2 elements
            //console.log(checkbox_element[0]);
            const checkbox_status = checkbox_element[0].checked;    // This will be true if the checkbox is in a selected state
            //console.log(`    checkbox status is: ${checkbox_status}`);

            // Now update the array of URI's selected for the bulk-update operation
            //console.log(`    this.checkboxes_selected (prior to update):  ${this.checkboxes_selected}`);
            if (checkbox_status) {
                //console.log(`    new box checked`);
                if (this.checkboxes_selected.includes(uri))  {  // Unexpected scenario
                    alert(`Attempting to select checkbox for URI: '${uri}' more than once; it's recommended to refresh the page and start over`);
                    return;
                }
                console.log(`    adding URI: '${uri}'`);
                this.checkboxes_selected.push(uri); // Beware: the Vue devtools requires a refresh to
                                                    //         show the updated value!
            }
            else  {
                console.log(`    removing URI: '${uri}'`);
                /*
                if (! this.checkboxes_selected.includes(uri))  {  // Unexpected scenario
                    alert(`Attempting to un-select checkbox for a URI ('${uri}') that wasn't selected; it's recommended to refresh the page and start over`);
                    return;
                }
                */
                // Remove from this.checkboxes_selected
                const index = this.checkboxes_selected.indexOf(uri);
                if (index == -1)    {       // Unexpected scenario
                    alert(`Attempting to un-select checkbox for a URI ('${uri}') that wasn't selected; it's recommended to refresh the page and start over`);
                    return;
                }
                this.checkboxes_selected.splice(index, 1);      // Removes 1 element from the array, at the specified position
            }

            console.log(`    this.checkboxes_selected:  [${this.checkboxes_selected}]`);
        },


        perform_bulk_operation()
        // Invoked when the user presses the "BULK RE-CLASSIFY" button
        {
            // Make sure that the selection isn't empty
            if (this.checkboxes_selected.length == 0)  {
                alert("No elements were selected for this bulk operation!  Use the checkboxes to select the elements first");
                return;
            }

            if (!this.category_to_move_to)  {
                alert("No Category was selected for this bulk operation!  Use the pulldown menu to select a Category first");
                return;
            }

            const category_from_uri = this.category_uri;
            const category_to_uri = this.category_to_move_to.uri;
            const category_to_name = this.category_to_move_to.name;

            console.log(`Bulk reclassifying the following Content Items:  [${this.checkboxes_selected}]`);
            console.log(`    moving them from Category URI '${category_from_uri}' (${this.category_name}) to URI '${category_to_uri}' (${category_to_name})`);


            // Send the request to the server, using a POST
            const url_server_api = "/BA/api/switch_category";
            const post_obj = {items: JSON.stringify(this.checkboxes_selected),
                              from: JSON.stringify(category_from_uri),
                              to: JSON.stringify(category_to_uri)};
            // TODO: maybe let contact_server() handle the JSON.stringify calls

            console.log(`About to contact the server at ${url_server_api} .  POST object:`);
            console.log(post_obj);

            // Initiate asynchronous contact with the server
            ServerCommunication.contact_server(url_server_api,
                        {post_obj: post_obj,
                         callback_fn: this.finish_perform_bulk_operation
                        });

            this.waiting = true;        // Entering a waiting-for-server mode
            this.error = false;         // Clear any error from the previous operation
            this.status_message = "";   // Clear any message from the previous operation
        },


        finish_perform_bulk_operation(success, server_payload, error_message, custom_data)
        // Callback function to wrap up the action of perform_bulk_operation() upon getting a response from the server
        {
            console.log("Finalizing the perform_bulk_operation() operation...");
            if (success)  {     // Server reported SUCCESS
                console.log("    server call was successful");
                this.status_message = `Items moved to other category`;
                console.log("    now updating page by removing items: ", this.checkboxes_selected);
                // Update the page, by ditching the Content Items that were moved away
                for (var uri of this.checkboxes_selected) {
                    let i = this.locate_item_simplified(uri);   // Find where the Content Item is stored in the array this.content_array
                    console.log(`    removing item with URI '${uri}' from page: array index is ${i}`);
                    this.content_array.splice(i, 1);            // Deletes 1 array element from the specified index position
                }
            }
            else  {                     // Server reported FAILURE
                this.error = true;
                this.status_message = `FAILED operation: ${error_message}`;
            }

            // Final wrap-up, regardless of error or success
            this.waiting = false;      // Make a note that the asynchronous operation has come to an end
        },



        adjust_left_sidebar(state)
        // Adjust the collapse/expansion of the left sidebar, based on the requested state: true = expanded; false = collapsed
        {
            //console.log(`Root element received signal to adjust the left sidebar, with state ${state}`);
            this.show_left_sidebar = state;
        },


        adjust_right_sidebox(state)
        // Adjust the collapse/expansion of the right sidebox, based on the requested state: true = expanded; false = collapsed
        {
            console.log(`Root element received signal to adjust the right sidebox, with state ${state}`);
            this.show_right_sidebox = state;
        },



        get_schema_data(item)
        // If the given Content Item is a record, return a list of its field names (Properties), in order
        {
            //if (item.schema_code != "r")
                //return [];                      // Nothing is being done for non-record Content Items (at least for now)

            const record_type = item.class_name;

            return this.records_schema_data[record_type] || [];     // If the requested key doesn't exist, return an empty array instead
                                                                    // TODO: if key is missing, query the server
        },


        add_subcategory()
        // Create a new sub-category for the current Category
        {
            const category_uri = this.category_uri;
            console.log(`Adding new sub-category: category_uri: ${category_uri}, subcategory name: ${this.new_subcategory_name} , remarks: ${this.new_subcategory_remarks}`);
            if (this.new_subcategory_name == "")  {
                alert("Must enter a Subcategory name");
                return;
            }

            // Send the request to the server, using a POST
            const url_server_api = "/BA/api/add_subcategory"
            // Compose the body of the POST to send to the server
            const post_obj = {category_uri: category_uri,
                              subcategory_name: this.new_subcategory_name,
                              subcategory_remarks: this.new_subcategory_remarks};

            // Initiate asynchronous contact with the server
            this.waiting = true;        // Entering a waiting-for-server mode
            this.error = false;         // Clear any error from the previous operation
            this.status_message = "";   // Clear any message from the previous operation
            ServerCommunication.contact_server(url_server_api,
                                               {post_obj: post_obj, callback_fn: this.finish_add_subcategory});
        },

        finish_add_subcategory(success, server_payload, error_message)
        /*  Callback function to wrap up the action of add_subcategory() upon getting a response from the server.
            If a new Subcategory is successfully added, the server_payload will contain the newly-assigned URI
         */
        {
            console.log("Finalizing the Add Subcategory operation...");
            if (success)  {     // Server reported SUCCESS
                this.status_message = `New sub-category successfully added (assigned URI '${server_payload}')`;
                // Update the data of the root component, to refresh some displays
                let new_subcategory = {uri: server_payload, name: this.new_subcategory_name};
                this.all_subcategories.push(new_subcategory);
                this.all_categories.push(new_subcategory);      // TODO: sort alphabetically
            }
            else  {             // Server reported FAILURE
                this.error = true;
                this.status_message = `FAILED addition of new Sub-category`;
            }

            // Final wrap-up, regardless of error or success
            this.waiting = false;      // Make a note that the asynchronous operation has come to an end
            // Clear up the form
            this.new_subcategory_name = "";
            this.new_subcategory_remarks = "";

        }, // finish_add_subcategory



        cancel_edit(item)
        {
            console.log(`Root module received signal to abort editing operation for item '${item.schema_code}' , id ${item.uri} , pos ${item.pos}`);
            if (item.uri == -1)  {
                // If we're aborting the edit of a new Content Item, delete it from the page
                index = this.locate_item_pos(item.schema_code, item.uri, item.pos);
                console.log(`Aborting the edit of a NEW Content Item, whose index position on the page is ${index}`);
                this.content_array.splice(index, 1);    // It modifies the array, to take out 1 element in position index
            }
        },



        insert_new_item_after(item, {schema_code, class_name})
        /*  Add a new Content Item of the specified type, placed after the specified Item;
            class_name is an OPTIONAL argument, only used for Content Item of type 'r' (but possibly being phased in for other types)
         */
        {
            //console.log(item);
            console.log(`In root component, insert_new_item_after()`);
            console.log(`    Insert after Item ID: ${item.uri}. New item - schema_code: ${schema_code}, class_name (optional): ${class_name}`);

            this.create_new_item_after(item.uri, schema_code, class_name);
        },


        create_new_item_after(insert_after_id, schema_code, class_name)
        {
            console.log(`In root component, create_new_item_after().  insert_after_id: ${insert_after_id} | schema_code: ${schema_code} |  class_name: ${class_name}`);

            const insert_after_index = this.locate_item_simplified(insert_after_id);
            console.log(`    Content item located in position ${insert_after_index}`);

            if (insert_after_index == -1)  {
                alert("Unable to locate the element after which to insert. Maybe a change was made on a separate tab...  Try refreshing page");
                return;
            }

            // Assemble the data for a new Content Item.  Using -1 as ID is a convention to indicate a NEW Content Item
            if (class_name)     // If a class name was passed, store it
                blank_record = {uri: -1, schema_code: schema_code, class_name: class_name, insert_after: insert_after_id};
            else                // No class name was provided
                blank_record = {uri: -1, schema_code: schema_code, insert_after: insert_after_id};

            // Insert the newly-created record after the specified existing element
            this.content_array.splice(insert_after_index + 1, 0, blank_record);

        }, // create_new_item_after



        add_new_item_at_bottom(schema_code, class_name)
        /*  Add a new Content Item of the specified type, placed at the bottom of the page (past the last Item);
            class_name is an OPTIONAL argument, historically only used for Content Item of type 'r' - but being
            phased in for other types
         */
        {
            console.log(`In root component, add_new_item_at_bottom().  Adding at the bottom of page new Content Item of type '${schema_code}' | class_name: ${class_name}`);

            // Assemble the data for a new Content Item.  Using -1 as ID is a convention to indicate a NEW Content Item
            // TODO: replace the -1 with an autoincrement unique number for the page
            if (class_name)   // If a class name was passed, store it
                blank_record = {"uri": -1, "schema_code": schema_code, "class_name": class_name, insert_after: "BOTTOM"};
            else             // No class name was provided
                blank_record = {"uri": -1, "schema_code": schema_code, insert_after: "BOTTOM"};

            this.content_array.push(blank_record);  // Insert a new blank Item at the end of the page's Content Items

        }, // add_new_item_at_bottom



        delete_content_item(item)
        // Delete from the page and from the database the specified Content Item
        {
            console.log(`Root element received signal to delete content item of type '${item.schema_code}' , id ${item.uri}`);
            const index = this.locate_item(item.schema_code, item.uri);
            console.log(`Content item located in position ${index}`);

            if (index == -1)  {
                alert("Unable to locate the element to delete. Maybe a change was made on a separate tab...  Try refreshing page");
                return;
            }

            url_server = `/BA/api/delete/${item.uri}/${item.schema_code}`;
            ServerCommunication.contact_server(url_server, {callback_fn: this.finish_delete, custom_data: index});
            //ServerCommunication.contact_server_TEXT(url_server, "", this.finish_delete, index);

        },  // delete_content_item()

        finish_delete(success, server_payload, error_message, index)
        // Callback function to wrap up the action of delete_content_item() upon getting a response from the server
        {
            console.log("Finalizing the deleting operation...");
            if (success)  {     // Server reported SUCCESS
                console.log(`    Removing from page the element with index ${index}`);
                this.content_array.splice(index, 1);  // It modifies the array, to take out 1 element in position index
            }
            else  {             // Server reported FAILURE
                alert("The server could not delete the Content Item. Perhaps it was deleted on another tab... Try saving your work and reloading the page");
            }

        }, // finish_delete



        move_up_content_item(item)
        //
        {
            const schema_code = item.schema_code;
            const uri = item.uri;

            console.log(`Root element received signal to move UP the content item of type '${schema_code}' , id ${uri}`);

            const number_items = this.content_array.length;

            if (number_items == 1)  {
                alert("There is only 1 item on the page!  No action taken");
                return;
            }

            const i = this.locate_item(schema_code, uri);     // Locate the specified Content Item in the array of Content Items

            if (i == -1)  {  // Not found
                alert(`Item type '${schema_code}' , id ${uri} NOT found. Maybe was deleted in another browser tab? No action taken`);
                return;
            }
            if (i == 0)  {
                alert("Item is already at the top: no action taken");
                return;
            }

            // Request the server to perform the operation on the data
            const swap_uri = this.content_array[i-1].uri;       // The ID of the Item that we're swapping with
            const url_server = `/BA/api/swap/${uri}/${swap_uri}/${this.category_uri}`;
            console.log(url_server);

            ServerCommunication.contact_server(url_server, {callback_fn: this.finish_move_up, custom_data: i});
            //ServerCommunication.contact_server_TEXT(url_server, "", this.finish_move_up, i);

        }, // move_up_content_item


        finish_move_up(success, server_payload, error_message, i)
        // Callback function to wrap up the action of move_up_content_item() upon getting a response from the server
        {
            console.log("Finalizing the move_up operation...");
            if (success)  {     // Server reported SUCCESS
                // Swap the position of the current Item with the one before it
                // Using Vue.set for the array operation to be "reactive" on the UI
                const old_value = this.content_array[i-1];                  // save item above
                Vue.set(this.content_array, i-1, this.content_array[i]);    // the item below moves up
                Vue.set(this.content_array, i, old_value);                  // (the saved) item above moves below
            }
        }, // finish_move_up



        move_down_content_item(item)
        //
        {
            const schema_code = item.schema_code;
            const uri = item.uri;

            console.log(`Root element received signal to move DOWN the content item of type '${item.schema_code}' , id ${item.uri}`);

            const number_items = this.content_array.length;

            if (number_items == 1)  {
                alert("There is only 1 item on the page!  No action taken");
                return;
            }

            const i = this.locate_item(schema_code, uri);     // Locate the specified Content Item in the array of Content Items

            if (i == -1)  {  // Not found
                alert(`Item type '${schema_code}' , id ${uri} NOT found. Maybe was deleted in another browser tab? No action taken`);
                return;
            }
            if (i == number_items - 1)  {
                alert("Item is already at the bottom: no action taken");
                return;
            }

            // Request the server to perform the operation on the data
            const swap_uri = this.content_array[i+1].uri;       // The ID of the Item that we're swapping with
            const url_server = `/BA/api/swap/${uri}/${swap_uri}/${this.category_uri}`;
            console.log(url_server);

            ServerCommunication.contact_server(url_server, {callback_fn: this.finish_move_down, custom_data: i});
            //ServerCommunication.contact_server_TEXT(url_server, "", this.finish_move_down, i);

        }, // move_down_content_item


        finish_move_down(success, server_payload, error_message, i)
        // Callback function to wrap up the action of move_up_content_item() upon getting a response from the server
        {
            console.log("Finalizing the move_down operation...");
            if (success)  {     // Server reported SUCCESS
                // Swap the position of the current Item with the one after it
                // Using Vue.set for the array operation to be "reactive" on the UI
                const old_value = this.content_array[i+1];                  // save item below
                Vue.set(this.content_array, i+1, this.content_array[i]);    // the item above moves down
                Vue.set(this.content_array, i, old_value);                  // (the saved) item below moves above
            }
        }, // finish_move_down




        absorb_item_updates_REVISED(new_data)
        /* Update the appropriate entry in this.content_array, with the new data passed by a component
           (generally done at the end of an update on the server.)
           NOT to be used for newly-added records: use absorb_item_updates() for those.
           
           new_data: object containing the special keys "uri" and "schema_code" (TODO: later replace with the internal_dbase_id),
                     used to identify the entry in this.content_array,
                     plus keys/values will all the other properties to update.  
                     Unaffected fields aren't expected to be included (but no harm if they are.)
                     EXAMPLE: {uri: '5622', schema_code: 'r', English: 'Woman', German: 'Frau'}
         */
        {
            //console.log("In absorb_item_updates_REVISED()");
            const schema_code = new_data.schema_code;
            const uri = new_data.uri;

            //console.log(`    Root element received signal to UPDATE the Content Item of type '${schema_code}' ,  uri '${uri}'`);
            //console.log(`    Data for the update:`);
            //console.log(new_data);

            const index = this.locate_item(schema_code, uri);         // TODO: switch to internal ID's

            if (index == -1)  {    // If the Item is not found on the page
                console.log(`    Failed to locate schema_code ${schema_code}, uri ${uri}`);
                alert("Unable to update the display.  Save your work and refresh the page");
            }

            // Bring the frontend up-to-date with the new data
            //console.log(`   Updating the Content Item found in content_array at index: ${index}`);


            let updated_record = Object.assign({}, this.content_array[index]);      // Start with a clone of the Content Item object
                                                                                    // (to allow for a complete record replacement for Vue reactivity)

            // Update all attributes, except "uri" and "schema_code", 
            // in the object that will replace the element in content_array at our index position
            for (key in new_data)  {    // Loop over all the keys in the object
                if (key != "uri"  &&  key != "schema_code")  {
                    let new_value = new_data[key];
                    if (new_value == "")  {
                        //console.log(`    Ditching the field '${key}'`);
                        delete updated_record[key];
                    }
                    else  {
                        //console.log(`    Updating field '${key}' with new value '${new_value}'`);
                        updated_record[key] = new_value;
                    }
                }
            }

            Vue.set(this.content_array, index, updated_record);     // Vue-reactive change (affecting the UI)
                                                                    // in the specified element of this.content_array

        }, // absorb_item_updates_REVISED



        absorb_item_updates(item, new_data)
        /*  Update the entry for the specified item in this.content_array, with the new data passed by a component
            (generally done at the end of an update on the server.)
            In terms of item's attributes:
                * "uri" in new_data can be different if it was a newly-added item (which is assigned a temporary value of -1)
                * "schema_code" doesn't vary under normal edits
                * "pos" is not changed thru edits (it uses separate mechanisms to reposition items)
                * everything else will be updated

            Note: this is an older version, probably to later be combined with absorb_item_updates_REVISED()
         */
        {
            //console.log(`Root element received signal to UPDATE the Content Item of type '${item.schema_code}' , original uri '${item.uri}'`);
            if (new_data.uri)
                console.log(`    A new current uri was passed: ${new_data.uri}`);

            //if (item.uri != -1)
                //alert("Attempting to modify an existing ID.  Request ignored...  Save your work and refresh the page");

            // **********  TODO:  The following will NOT work if there's more than one NEW item of the same type!!!!!
            // 2 strategy ideas: 1) for new items, assign temp ID's of -1, -2, -3, etc. (instead of giving -1 to all)
            //                   2) search by ID (-1) AND by pos
            const index = this.locate_item(item.schema_code, item.uri);         // TODO: switch to internal ID's

            if (index == -1)    // If the Item is not found on the page
                alert("Unable to update the display so as to set the ID of the newly-added Content Item.  Save your work and refresh the page");

            // Bring the frontend up-to-date with the new data (possibly including the URI just assigned by the server for new Items)
            //console.log(`Updating the Content Item found in content_array at index: ${index}`);
            //console.log("The original Content Item is:");
            //console.log(item);

            //console.log("The current value of content_array at index: ${index}` is:");
            //console.log(this.content_array[index]);

            //console.log("The new data (sent thru the Vue signal) is:");
            //console.log(new_data);
            
            
            let updated_record = Object.assign({}, this.content_array[index]);      // Start with a clone of the Content Item object
                                                                                    // (to allow for a complete record replacement for Vue reactivity)

            // Update all attributes, except "pos" and "schema_code",
            // in the object that will replace the element in content_array at our index position
            for (key in new_data)  {    // Loop over all the keys in the object
                if (key != "pos" && key != "schema_code")  {
                    let new_value = new_data[key];
                    //console.log(`    Updating value of key '${key}' with new value '${new_value}'`);
                    updated_record[key] = new_value;
                }
            }

            // Ditch any fields that were deleted in the edit (however, "pos", "schema_code", "class_name", "uri" are left alone)
            // TODO: editable fields and non-editable ones (such as the special cases above) ought to be treated differently
            for (old_key in updated_record)
                if ((old_key != "pos") && (old_key != "schema_code") && (old_key != "class_name") && (old_key != "uri") && !(old_key in new_data))  {
                    //console.log(`    Ditching the old field '${old_key}' because it was eliminated in the edit`);
                    delete updated_record[old_key];
                }
                
            Vue.set(this.content_array, index, updated_record);     // Vue-reactive change (affecting the UI)
                                                                    // in the specified element of this.content_array
                                                                    
        }, // absorb_item_updates



        relocate_content_item(item, where_to)
        /*  (At the request of another component) Relocate the specified Item within the page, to be placed after specified position,
            and inform the server of this operation.
            Note: where_to is a 1-based index of Content Items on the page; by our convention, 0 means "move to top"
         */
        {
            const schema_code = item.schema_code;
            const uri = item.uri;

            console.log(`Root element received signal to RELOCATE the content item of type '${item.schema_code}' , id ${item.uri} to just after the ${where_to}-th entry, within category ${this.category_uri}`);

            const number_items = this.content_array.length;

            if (number_items == 1)  {
                alert("There is only 1 item on the page!  No action taken");
                return;
            }

            const i = this.locate_item_simplified(uri);     // Locate the specified Content Item in the array of Content Items

            if (i == -1)  {  // Not found
                alert(`Item type '${schema_code}' , id ${uri} NOT found. Maybe was deleted in another browser tab? No action taken`);
                return;
            }

            status = this.reposition_content(i, where_to);

            if (!status)  {
                alert("The move operation failed.  Refresh the page and try again");
                return;
            }

            // Request the server to perform the operation on the database
            const url_server = `/BA/api/reposition/${this.category_uri}/${uri}/${where_to}`;
            console.log(url_server);

            ServerCommunication.contact_server(url_server, {callback_fn: this.finish_relocate_content_item, custom_data: i});
            //ServerCommunication.contact_server_TEXT(url_server, "", this.finish_relocate_content_item, i);

        }, // relocate_content_item



        finish_relocate_content_item(success, server_payload, error_message, i)
        // Callback function to wrap up the action of finish_relocate_content_item() upon getting a response from the server
        {
            console.log("Finalizing the finish_relocate_content_item operation...");
            if (!success)  {     // Server reported FAILURE
                alert("The server could not move the Content Item. Perhaps items were repositioned on another tab.  Save your work and reload the page");
            }
        }, // finish_relocate_content_item



        reposition_content(index_of_moved_item, move_after_n)
        /*  Relocate the Item (specified by its index) within the page, to be placed after the n-th item.
            Return true if successful, or false otherwise.
            IMPORTANT: index_of_moved_item is zero-based, while move_after_n starts at 1 (0 means "move to top")
         */
        {
            if (index_of_moved_item < 0 || index_of_moved_item >= this.content_array.length) {
                console.error(`index_of_moved_item ${index_of_moved_item} is out of bounds.  Expected range is [0-${this.content_array.length - 1}]`);
                return false;
            }

            if (move_after_n < 0 || move_after_n > this.content_array.length) {
                console.error(`move_after_n ${move_after_n} is out of bounds.  Expected range is [0-${this.content_array.length}]`);    // Note it's 1 longer than the range of index_of_moved_item
                return false;
            }

            if (move_after_n == index_of_moved_item) {
                console.error(`Attempting to reposition to same location: index_of_moved_item and move_after_n are equal (both ${move_after_n})`);
                return false;
            }

            console.log(`Relocate the ${index_of_moved_item}-th Item on the page, to be moved after position ${move_after_n}`);

            const being_moved = this.content_array[index_of_moved_item];    // The object with the data of the Content Item being moved

            this.content_array.splice(move_after_n, 0, being_moved);        // Insert it at the given position

            if (move_after_n < index_of_moved_item)
                index_of_moved_item += 1;                                   // If the insertion took place before the element to take out, adjust its index

            this.content_array.splice(index_of_moved_item, 1);              // Take it out from the array of Content Items

                                                                            // (Note: Vue automatically detects array changes done with splice)
            return true;

        }, // reposition_content



        locate_item_simplified(uri)
        /*  Locate the specified Content Item in the array of Content Items.
            The item is identified by its uri.
            If found, return its index in the array; otherwise, return -1
            (No check is done as to whether there might be more than one match; the first one is returned.)
            TODO: consider using Lodash library (https://lodash.com/docs/4.17.15#findIndex)
         */
        {
            //console.log(`Attempting to locate content item with id ${uri}`);

            const number_items = this.content_array.length;

            for (var i = 0; i < number_items; i++) {
                if (this.content_array[i].uri == uri)
                    return i;          //  Found it
            }

            return -1;    // Didn't find it
        },

        locate_item(schema_code, uri)
        /*  TODO: maybe phase out in favor of locate_item_simplified()
            TODO: consider using Lodash library (https://lodash.com/docs/4.17.15#findIndex)

            Helper function, to locate the specified Content Item in the array of Content Items.
            The item is identified by its schema_code and uri.  (Note: schema_code is redundant.)
            If found, return its index in the array; otherwise, return -1
            (No check is done as to whether there might be more than one match; the first one is returned.)
         */
        {
            //console.log(`Attempting to locate content item of type '${schema_code}' , id ${uri}`);

            const number_items = this.content_array.length;

            for (var i = 0; i < number_items; i++) {
                if (this.content_array[i].schema_code == schema_code  &&  this.content_array[i].uri == uri)
                    return i;          //  Found it
            }

            return -1;    // Didn't find it
        },


        locate_item_pos(schema_code, uri, pos)
        /*  Same as locate_item(), but also requiring a match on position.  ONLY USED TO TAKE OUT NEW ITEMS WHOSE ADDITION GOT CANCELLED
         */
        {
            //console.log(`Attempting to locate content item of type '${schema_code}' , id ${uri}, pos ${pos}`);

            const number_items = this.content_array.length;

            for (var i = 0; i < number_items; i++) {
                if (this.content_array[i].schema_code == schema_code  &&
                    this.content_array[i].uri == uri  &&
                    this.content_array[i].pos == pos)
                    return i;          //  Found it
            }

            return -1;    // Didn't find it
        },


        plugin_component_name_MOVED(item)
        // Compose the name of the plugin-provided Vue component to handle the given item (based on its type)
        {
            // TODO: make sure that item.schema_code is known, or return a special "generic" type
            return "vue-plugin-" + item.schema_code;
        },




        /*  -------------------------------------------------------------------------------------------
                    The methods below are used to implement GROUPING of similar consecutive
                    content items of type "Record"
            -------------------------------------------------------------------------------------------
         */

        canonical_field_list(content_item)
        /*  Canonical order means the Item's fields in the schema go first, in the schema order,
            followed by any other field not in the Schema, in order of appearance.

            Standard fields (i.e. all fields that won't appear in a tabular format) are ignored.
            TODO: simplify with Lodash

            EXAMPLES (assuming that the Schema for "Quotes" is ["quote", "attribution", "notes"]):
                {"pos":10, "uri":1, "extra": "some value"}
                    ->  [ "extra" ]
                {"pos":10, "uri":1, "extra": "some value", class_name:"Quotes"}
                    ->  [ "extra" ]
                {"pos":10, "notes": "my note", "uri":1, "extra": "some value", class_name:"Quotes"}
                    ->  [ "notes", "extra" ]
                {"pos":10, "notes": "my note", "uri":1, "extra": "some value", class_name:"Quotes", "quote": "My quote"}
                    ->  [ "quote", "notes", "extra" ]
                {"extra": "some value", "attribution": "Napoleon", "pos":10, "notes": "my note", "uri":1,  class_name:"Quotes", "quote": "My quote"}
                    ->  [ "quote", "attribution", "notes", "extra" ]
                {"attribution": "Napoleon", "pos":10, "notes": "my note", "uri":1,  class_name:"Quotes", "quote": "My quote"}
                    ->  [ "quote", "attribution", "notes" ]
                {"extra": "some value", "attribution": "Napoleon", "pos":10, "notes": "my note", "extra2": "some other value", "uri":1,  class_name:"Quotes", "quote": "My quote"}
                    ->  [ "quote", "attribution", "notes", "extra", "extra2" ]
                {"extra": "some value", "attribution": "Napoleon", "pos":10, "notes": "my note", "extra2": "some other value", "uri":1,  class_name:"UNKNOWN", "quote": "My quote"}
                    ->  [ "extra", "attribution", "notes", "extra2", "quote" ]
         */
        {
            let field_list = this.extract_fields(content_item);

            if (! ("class_name" in content_item))
                return field_list;      // No Schema field found


            const class_name = content_item.class_name;

            if (! (class_name in this.records_schema_data))  {
                console.log(`No Schema information available for class '${class_name}'`);
                return field_list;  // No Schema information available for this class; TODO: query server
            }

            const schema_list = this.records_schema_data[class_name];

            let canonical_list = [];
            // Add all the Schema fields that are in the item's field list
            for (let i = 0; i < schema_list.length; i++)
                if (field_list.includes(schema_list[i]))
                    canonical_list.push(schema_list[i]);

            // Add all the item's fields that aren't in its Schema (non-standard fields, if any)
            for (let i = 0; i < field_list.length; i++)
                if (! schema_list.includes(field_list[i]))
                    canonical_list.push(field_list[i]);

            return canonical_list;
        },


        build_groupings()
        // Lump together consecutive Content Items, if they meet a set of criteria
        {
            groupings_list = [];

            const num_items = this.content_array.length;
            const parsing = [];     // Helper intermediate structure

            for (let i = 0; i < num_items-1; i++) {     // Stop 1 before the last Content Item on the page
                let merge = this.should_group_with_next(i);
                parsing.push(merge);
            }
            parsing.push(false);    // The last Content Item cannot be merged with a "next" one

            //console.log('parsing array: ', parsing);

            let active_index = -1;

            for (let i = 0; i < num_items; i++) {
                if (active_index == -1)  {   // If there no group-in-progress
                    if (parsing[i])
                        active_index = i;                                                   // Reset group start
                    else  {
                        // Export singleton
                        if (this.content_array[i].schema_code == "r")  {
                            let field_list = this.canonical_field_list(this.content_array[i]);
                            groupings_list.push({index: i, group_size: 1, use_group: true, fields: field_list});
                        }
                        else
                            groupings_list.push({index: i, group_size: 1, use_group: false});
                    }
                }
                else  {                     // If there's a group-in-progress
                    if (!parsing[i])  {
                        let field_list = this.canonical_field_list(this.content_array[active_index]);
                        // Export group
                        groupings_list.push({index: active_index, group_size: i-active_index+1, use_group: true, fields: field_list});
                        active_index = -1;  // terminate the current group-in-progress
                    }
                    // if (parsing[i]), no action is needed
                }
            }

            return groupings_list;

        }, // build_groupings()



        should_group_with_next(i)
        /*  Return a Boolean depending on whether Content Item i and the next one should be merged
            based on their structure similarity
         */
        {
            const item_i = this.content_array[i];
            const item_j = this.content_array[i+1];

            if (item_i.schema_code != "r"  ||  item_j.schema_code != "r")
                return false;       // We're only grouping Content Items of type "record"

            if (item_i.class_name != item_j.class_name)
                return false;

            const fields_i = this.extract_fields(item_i);
            const fields_j = this.extract_fields(item_j);

            //console.log('Examining record with index: ', i);
            //console.log('  fields_i: ', fields_i);
            //console.log('  fields_j: ', fields_j);

            if (!this.compare_arrays(fields_i, fields_j)) {  // Allows variations in field order
                //console.log('    the field lists differ');
                return false;
            }

            //console.log('    the field lists are the same');
            return true;
        },


        extract_fields(content_item)
        /*  Scrub out all the standard fields (i.e. all fields that won't appear in a tabular format)
            EXAMPLE:  {"pos":10, "uri":1, "schema_code":"r", class_name:"German Vocabulary",
                             "German":"Leben", "English":"life"}
                       will return  [ "German", "English" ]

            TODO: maybe the objects in content_array ought to keep the 2 types of fields separate
         */
        {
            let shown_fields = [];
            let all_fields = Object.keys(content_item);

            // TODO: maybe use Lodash _.difference function
            for (i in all_fields) {
                key = all_fields[i];
                if (key != "pos" && key != "uri" && key != "schema_code" && key != "class_name")
                    shown_fields.push(key);
            }

            return shown_fields;
        },


        compare_arrays(a1, a2)
        /*  Compare two flat arrays regardless of element order.
            Return true if have the same elements, whether in same or scrambled order - or false otherwise.
            TODO: maybe there's a Lodash method
         */
        {
            if (a1.length != a2.length)
                return false;

            // The "slice" method clones the array (otherwise, the passed variable will be altered)
            const a1_sorted = a1.slice().sort();
            const a2_sorted = a2.slice().sort();

            for (let i = 0; i < a1.length; i++)
                if (a1_sorted[i] != a2_sorted[i])
                    return false;   // A difference was found

            return true;
        }

    } // METHODS

});
</script>


</body>
</html>