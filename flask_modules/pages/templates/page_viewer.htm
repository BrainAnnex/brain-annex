<!DOCTYPE html>
{#  General viewer page for a list of Content Items (the list is specified in Flask parameter content_items)
    Vue.js is used for the rendering

    Flask-passed parameters:

        site_data           A dict (for details, see BA_pages_routings.py)
        current_page
        username

        category_uri        A string with the URI of the Category featured on this page
        category_name       The name of the above Category
        category_remarks    Descriptive extra text about this Category (may be missing)

        all_categories      A list of dicts.  Note that the 'remarks' and 'pinned' keys may or may not be present.
                                    EXAMPLE:
                                          [{"uri": "1",   "name": "HOME", "remarks": "ROOT NODE"},
                                           {"uri: "123",  "name": "Calculus"},
                                           {"uri": "523", "name": "Work at Acme", "pinned": True}]
        subcategories       EXAMPLE: [{'uri': '2', 'name': 'Work', remarks: 'outside employment', OTHER_FIELDS_NOT_USED}]
        parent_categories
        siblings_categories

        bread_crumbs    A list with data from which to create UI "bread crumbs"

        see_also_links  A list with data about all the "see also" links originating from this Category
                            EXAMPLE:  [{'name': 'Quotes', 'uri': '823', 'remarks': None}]

        records_types   A list of all the Classes that can be used for new Records
                            (i.e. classes that are INSTANCE_OF the "Records" class)
                            EXAMPLE: ["Cuisine Type","Entrees","French Vocabulary","German Vocabulary","Restaurants","Site Link"]
                            Used for the addition of new records
                            (TODO: maybe obtain thru a server call, when first needed)

        items_schema_data: A dictionary of record class names, mapped into the ordered list of their property names.
                             Ancestral Properties, thru "INSTANCE_OF", are also included.
                             However, Properties that have the attribute "system" set to True (such as "uri"), are excluded
                             EXAMPLE:
                                 {"Quote": ["quote", "attribution", "notes"],
                                  "French Vocabulary": ["French", "English", "notes"],
                                  "Site Link": ["url", "name", "date", "comments", "rating", "read"]
                                 }

        content_items:  A list of dictionaries
                        EXAMPLE:
                            [{'schema_code': 'i', 'uri': 'i-1','width': 450, 'basename': 'my_pic', 'suffix': 'PNG', pos: 0, 'class_name': 'Image'},
                             {'schema_code': 'h', 'uri': 'h-23', 'text': 'Overview', pos: 10, 'class_name': 'Header'},
                             {'schema_code': 'n', 'uri': 'n-41', basename': 'overview', 'suffix': 'htm', pos: 20, 'class_name': 'Note'},
                             {'schema_code': 'rs', 'class_handler': 'recordsets', 'class_name': 'Recordset', 'uri': '6965', 'pos': 86,
                                                         'n_group': '4', 'order_by': 'name', 'class': 'YouTube Channel'}
                            ]

        upload_directories: A list of folders registered with BrainAnnex
                            EXAMPLE:
                                ["documents/Ebooks & Articles",
                                "documents/Ebooks & Articles/Computer Science"]

    -----------------------------------------------------------------------------------
    MIT License.  Copyright (c) 2021-2025 Julian A. West and the BrainAnnex.org project
	-----------------------------------------------------------------------------------
 #}


<html lang="en">
<head>
    <title>{{category_name}}</title>

    <!-- General and module styling -->
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/css/brain_annex.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/css/page_viewer.css">

    <link type="text/css" rel="stylesheet" href="/navigation/static/horiz_status_bar.css">
    <link type="text/css" rel="stylesheet" href="/navigation/static/navbar_top.css">

    <link type="text/css" rel="stylesheet" href="/BA/pages/static/modules/dropzone/dropzone.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/modules/dragscroll/dragscroll.css">

    <link rel="stylesheet" href="/BA/pages/static/modules/awesomplete/awesomplete.css">


    <!-- Styling for Vue CORE components -->
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/bread_crumbs/bread_crumbs.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/toc_sidebar/toc_sidebar.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/category_navbox/category_navbox.css">

    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/content_items/content_items.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/controls/controls.css">

    <!-- PLUGIN-specific styling -->
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/PLUGINS/headers/headers.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/PLUGINS/images/images.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/PLUGINS/documents/documents.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/PLUGINS/notes/notes.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/PLUGINS/codedocs/codedocs.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/PLUGINS/site_link/site_link.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/PLUGINS/recordsets/recordsets.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/PLUGINS/records/records.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/vue_components/PLUGINS/timer/timer.css">

    <!-- JavaScript -->
    <script src="/BA/pages/static/Vue2/vue2.js"></script>   <!-- Vue.js (version 2) -->
    <script src="/BA/pages/static/modules/CKeditor/ckeditor.js"></script>
    <script src="/BA/pages/static/modules/dropzone/dropzone.js"></script>
    <script src="/BA/pages/static/modules/dragscroll/dragscroll.js"></script>
    <script src="/BA/pages/static/modules/awesomplete/awesomplete.js"></script>

    <script src="/BA/api/static/server_communication.js"></script>
</head>


<body>


<div id="vue-root">   <!-- Container for VUE COMPONENTS : the ROOT of the components below -->


{# HORIZONTAL STATUS BAR (fixed at the top) #}
{% with header_title=category_name %}
    {% include "horiz_status_bar.htm" %}
{% endwith %}



<!--   The "scroll-canvas" is the MAIN part of the page,
       incl. the navbar at the top and the sidebox on the right,
       but exclusive of the left sidebar, which is fixed in position.
       If the left sidebar is collapsed, then the "scroll-canvas" needs a different size -->
<div v-bind:class="{ 'scroll-canvas': show_left_sidebar, 'scroll-canvas--collapsed-left': !show_left_sidebar }">



{# TOP NAVIGATION BAR (scrolls with main part of page) #}
{% include "navbar_top.htm" %}




<!-- ****************************************************************

                LEFT side-bar (used for Table of Contents)

     **************************************************************** -->

<vue-toc-sidebar
    v-bind:content_array="content_array"
    v-bind:show_left_sidebar="show_left_sidebar"

    v-on:adjust-left-sidebar="adjust_left_sidebar($event)"
>
</vue-toc-sidebar>



<!-- ****************************************************************

               RIGHT side-box (with Category navigation)

 **************************************************************** -->

<vue-category-navbox
    v-bind:category_name="category_name"
    v-bind:current_category_uri="category_uri"
    v-bind:parent_categories="parent_categories"
    v-bind:subcategories="all_subcategories"
    v-bind:siblings_categories="siblings_categories"
    v-bind:all_categories="all_categories"
    v-bind:show_right_sidebox="show_right_sidebox"

    v-on:adjust-right-sidebox="adjust_right_sidebox($event)"
>
</vue-category-navbox>




<!-- Manage the expansion/contraction of the right sidebox -->
<div v-bind:class="{ 'lightbox': show_right_sidebox, 'lightbox--expand-right': !show_right_sidebox }">




<!-- ****************************************************************

                        TOP OF PAGE

 **************************************************************** -->

{#  Uncomment for DEBUGGING! (to view some of the Flask-passed parameters)
    <br><b>siblings_categories</b>:<br>{{siblings_categories}}<br><br>
    <br><b>all_categories</b>:<br>{{all_categories}}<br><br>
 #}



<!-- Bread crumbs for this Category -->
<vue-bread-crumbs
    v-bind:category_uri="category_uri"
    v-bind:bread_crumbs="bread_crumbs"
    v-bind:all_categories="all_categories"
>
</vue-bread-crumbs>



<form method='GET' action='target_page.htm'  id='ajax-form'  style='float:right; padding-right:5px;'>
    <span style="color:gray">Category Navigator</span><br>
    <img src='/BA/pages/static/graphics/magnifier.png' alt='Go to Category' title='Go to Category'>
    <input id='category_navigator' type='text' name='text' size='35' v-model="category_input_navigator">
</form>




{# Display prominently this page's Category's name and, if appropriate, its controls #}
{% if category_name %}
<p class="headline"   @dblclick="toggle_edit_mode()"  title="Double-click to toggle page edit mode">
    [[category_name]]
    <span style="color:gray; margin-left:25px; font-size:10px">{{category_remarks}}</span>
    {# Category management #}
    <a v-if="expose_controls"  href="/BA/pages/category_manager/{{category_uri}}"  target="_blank"  style="margin-left:15px">
        <img src='/BA/pages/static/graphics/edit_16_2530834.png' alt='EDIT category (rename, etc.)' title='EDIT category (rename, etc.)'>
    </a>
    <a v-if="expose_controls"  @click="bulk_operations = !bulk_operations"  class="clickable-icon"  style='margin-left:20px'>
        <img src='/BA/pages/static/graphics/bulk_operation_16_1031512.png'
             alt='Toggle BULK operations (tag, move, delete)' title='Toggle BULK operations (tag, move, delete)'>
    </a>
</p>
{% endif %}


{# Display all subcategories (at the top) #}
<div v-if="all_subcategories.length > 0" class='subsections'>
    <span class='subsections-label'>Subcategories: </span>
    <template v-for="(subcategory, index) in all_subcategories" class='subsection-link'>
        <span v-if="index == 0" class='subsection-link'><a v-bind:href="'/BA/pages/viewer/' + [[ subcategory['uri'] ]]">[[ subcategory['name'] ]]</a></span>
        <span v-else class='subsection-link'>&nbsp; &diams; &nbsp;<a v-bind:href="'/BA/pages/viewer/' + [[ subcategory['uri'] ]]">[[ subcategory['name'] ]]</a></span>
    </template>
</div>



{# Display all the "SEE ALSO" links, if present #}
{% if see_also_links != [] %}
    <p style="margin-bottom:15px">
        -> <b>SEE ALSO:</b>&nbsp;&nbsp;&nbsp;
        {% for linked_category in see_also_links %}
            <a href="/BA/pages/viewer/{{linked_category.uri}}" style="margin-right:30px">
                {{linked_category.name}}
            </a>
        {% endfor %}
    </p>
{% endif %}



{# Give notice if no Content Items were passed #}
<p v-if="is_page_empty" style="margin-top:50px; color:#888">
    NO CONTENT ITEMS FOUND : you need to add or upload them
</p>





<!-- ****************************************************************

                        MAIN LOOP of Content Items

 **************************************************************** -->

<!-- Depending on whether the EDITING CONTROLS are shown or hidden,
     one of the following 3 blocks gets shown
  -->


<!--  ---------------  SCENARIO 1 : When editing controls SHOWN   ---------------

     To be used when the EDITING CONTROLS are SHOWN (but NOT when in BULK-operation mode):
     all the Content Items are shown as individual entities,
     handled by their respective Vue components

     For each Content Item on this page, make use of the 'vue-content-items' Vue component,
     which in turn dispatches to the appropriate Vue component (picked dynamically based on the Content Item's type).
     Handle here some UI operations common to all types, such as moves around the page.
     Type-specific operations, such as editing, are handled by the individual components

     v-bind:key Used to provide unique identifiers for each Vue component (it may change if content_array changes)
     v-bind:is  Specifies which component to use, based on the type of the Content Item

     Props (arguments) passed to the components [some are meant for the 'vue-controls' sub-components]
            v-bind:item="item"
            v-bind:expose_controls="expose_controls"
            v-bind:category_uri="category_uri"
            v-bind:index="index"                        Zero-based position of the Content Item on the page
            v-bind:item_count="content_array.length"

            v-bind:records_types="records_types"

            v-bind:schema_data="get_schema_data(item)"  Only used for Content Items of type Record (schema_code "r").
                                                        A list of field names, in order.
                                                        EXAMPLE: ["French", "English", "notes"]

     Intercept various SIGNALS from *descendant* components:
        Originating in grandchildren:
            v-on:delete-content-item
            v-on:move-up-content-item
            v-on:move-down-content-item
        Originating in *direct children* components:
            v-on:cancel-edit
            v-on:updated-item
            v-on:insert-new-item-after
     -->

<template v-if="expose_controls && !bulk_operations"  v-for="(item, index) in content_array">

    <vue-content-items
        v-bind:key="item.schema_code + '_' + item.uri + '_' + index"

        v-bind:item="item"
        v-bind:expose_controls="expose_controls"
        v-bind:category_uri="category_uri"
        v-bind:index="index"
        v-bind:item_count="content_array.length"

        v-bind:registered_plugins = "registered_plugins"
        v-bind:records_types="records_types"

        v-bind:schema_data="get_schema_data(item)"
        v-bind:all_categories="all_categories"

        v-on:delete-content-item-highlighted="delete_content_item(item)"
        v-on:move-up-content-item="move_up_content_item(item)"  v-on:move-down-content-item="move_down_content_item(item)"
        v-on:relocate-content-item="relocate_content_item(item, $event)"
        v-on:cancel-edit="cancel_edit(item)"
        v-on:updated-item="absorb_item_updates(item, $event)"
        v-on:insert-new-item-after="insert_new_item_after(item, $event)"
    >
    </vue-content-items>

</template>




<!-- ---------------   SCENARIO 2 : For BULK OPERATIONS  ---------------

    List all Content Items "normally" (like in viewing mode), but
    interspersed with paragraphs - which force new lines - that contain
    checkboxes, and links to help check multiple boxes at once.

    At the bottom, display controls to actually perform the operation.

  -->

<p v-if="bulk_operations" style="font-size: 20px; font-weight: bold">
    <a @click.prevent="reset_checkboxes()" href="#">CLEAR ALL checkmarks</a>
</p>


<template v-if="bulk_operations"  v-for="(item, index) in content_array">

    <vue-content-items
            v-bind:key="item.uri + '_bulk'"

            v-bind:item="item"
            v-bind:expose_controls="false"
            v-bind:category_uri="category_uri"
            v-bind:index="index"
            v-bind:item_count="content_array.length"

            v-bind:registered_plugins = "registered_plugins"
            v-bind:records_types="records_types"

            v-bind:schema_data="get_schema_data(item)"
            v-bind:all_categories="all_categories"
    >
    </vue-content-items>


    <!-- TODO: maybe the binding to the input element should include class_name besides uri -->
    <p style="margin-top:0; margin-bottom:40px">
        <input type="checkbox"  v-bind:ref="item.uri"  @click="bulk_checkbox_clicked(item, index)">

        <span v-if="! checkboxes_selected.includes(index)">
            <a v-if="group_boundary === null" @click.prevent="contiguous_group(item, index)" href="#" style="margin-left: 15px">
                Select the FIRST or LAST of a contiguous group
            </a>

            <a v-if="group_boundary !== null" @click.prevent="contiguous_group(item, index)" href="#" style="margin-left: 15px">
                Select the END of the contiguous group
            </a>
        </span>
    </p>

</template>


<template v-if="bulk_operations">

    <p style="font-size: 20px; font-weight: bold">
        <a @click.prevent="reset_checkboxes()" href="#">CLEAR ALL checkmarks</a>
    </p>

    <p style="margin-left:15px; font-style:italic">
        Move the selected items to a new category:
    </p>

    <button @click="perform_bulk_operation"
        style="margin-left:15px; margin-right:15px; margin-bottom:30px; padding:20px; font-size:24px; font-weight:bold; border:1px solid #660000; background-color:#00cc00; color:#fff; border-radius:15px">
        BULK RE-CLASSIFY
    </button>

    <span style="font-style:bold; font-size:18px">AS...</span>

    <select v-model="category_to_move_to"
            v-bind:title="'Reclassify the selected Content Items with a different Category tag'"
            style='margin-left:15px'>
        <option disabled value="">[Select new tag]</option>
        <option v-for="cat in all_categories"
                v-if="cat.uri != category_uri"
                v-bind:value="{uri: cat.uri , name: cat.name}">
            [[cat.name]]
        </option>
    </select>

    <br>
    <span v-if="waiting" class="waiting">Performing the bulk operation...</span>
    <span v-bind:class="{'error-message': error, 'status-message': !error }">[[status_message]]</span>
    <br><br>
</template>




<!-- ---------------  SCENARIO 3 : editing controls HIDDEN)  ---------------

    To be used when the EDITING CONTROLS are HIDDEN (i.e. in viewing mode.)
  -->

<template v-if="!expose_controls"  v-for="(item, index) in content_array">

    <!-- Show here the individual Content Item -->
    <vue-content-items
            v-bind:key="index + '_' + item.uri"

            v-bind:item="item"
            v-bind:expose_controls="expose_controls"
            v-bind:category_uri="category_uri"
            v-bind:index="index"
            v-bind:item_count="content_array.length"

            v-bind:registered_plugins = "registered_plugins"
            v-bind:records_types="records_types"

            v-bind:schema_data="get_schema_data(item)"

            v-on:delete-content-item-highlighted="delete_content_item(item)"
            v-on:move-up-content-item="move_up_content_item(item)"  v-on:move-down-content-item="move_down_content_item(item)"
            v-on:relocate-content-item="relocate_content_item(item, $event)"
            v-on:cancel-edit="cancel_edit(item)"
            v-on:updated-item="absorb_item_updates(item, $event)"
            v-on:insert-new-item-after="insert_new_item_after(item, $event)"
    >
    </vue-content-items>


</template>




<a name="BOTTOM"></a>   <!-- Anchor for page scrolling to the bottom of the page-->


<br><br>


<!-- BOX FOR INSERTION OF NEW CONTENT AT BOTTOM OF THIS PAGE -->
<div v-show="expose_controls && !bulk_operations">

    <h3>Add at the bottom of page</h3>
    <span style="margin-right:10px">Add new:</span>
    <!-- TODO: automate these choices, based on Schema.  Merge with similar box in content_items.js -->
    <button @click="add_new_item_at_bottom('h', 'Header')" style="margin-right:10px">Header</button>
    <button @click="add_new_item_at_bottom('n', 'Note')" style="margin-right:10px">Note</button>
    <button @click="add_new_item_at_bottom('sl', 'Site Link')" style="margin-right:10px">Site Link (Bookmark)</button>
    <button @click="add_new_item_at_bottom('rs', 'Recordset')" style="margin-right:10px">Recordset</button>
    <button @click="add_new_item_at_bottom('cd', 'Code Documentation')" style="margin-right:10px">Code Documentation (deprecated)</button>
    &nbsp;&nbsp;&nbsp;
    <button @click="add_new_item_at_bottom('timer', 'Timer Widget')" style="margin-right:10px">Timer Widget</button>

    <!-- Show all leaf Classes that are direct instances of "Records" -->
    <br>Add new record of type:
    {% for class_name in records_types %}
        <button @click='add_new_item_at_bottom("r", "{{class_name}}")'
                class="record-picker"
                style="color: {% if (loop.index % 7) == 1 %}#ae9cd6{% elif (loop.index % 7) == 2 %}#8bb9d4{% elif (loop.index % 7) == 3 %}#a6cfa1{% elif (loop.index % 7) == 4 %}#dad6a1{% elif (loop.index % 7) == 5 %}#e1b298{% elif (loop.index % 7) == 6 %}#e59ca0{% elif (loop.index % 7) == 0 %}gray{% else %}black{% endif %}">
            {{class_name}}
        </button>
    {% endfor %}

    <br>


    <div style='border:1px solid gray; padding:10px; background-color:#DDDDDD; margin-top:5px; margin-bottom:5px; margin-right:5px'>		<!-- Maybe the DIV wrapper could be ditched? -->

        <b>UPLOAD IMAGES or DOCUMENTS</b> (if no upload directory is specified, a standard location will be used - documents ONLY, for now) :<br>

        <form action='/BA/api/upload_media' class='dropzone' id='myDropzone_d' style='padding-top:5px; margin-bottom:8px'>
            <select name='upload_folder'  style='font-size:9px'>
                <option selected value=''>[USE DEFAULT UPLOAD DIRECTORY]</option>

                {% for dir in upload_directories %}
                    <option value="{{dir}}">{{dir}}</option>
                {% endfor %}
            </select>
            <input type='hidden' name='category_id' value='{{category_uri}}'>
            <input type='hidden' name='insert_after_uri' value='INSERT_AT_BOTTOM'>
        </form>

        <!--  The "DONE" button simply reloads the viewer page -->
        <a href='' style='font-size:18px; border:1px solid #660000; background-color:#00cc00; text-decoration:none; color:#fff; border-radius:5px; padding:4px'>Done</a>
        <span style='color:gray; margin-left:20px; font-size:10px'>Press the "Done" button when all uploads are complete, to reload the page</span><br>

    </div>	<!--  Terminate the wrapper DIV for uploads -->





    <!--  To add a new Subcategory (TODO: turn into a Vue component) -->
    <div style='clear: left;'></div> {# To clear any Content Item #}

    <div class='form-box' style="float:right">
        <span class='title'>CREATE A NEW SUBCATEGORY for &ldquo;{{category_name}}&rdquo;</span><br><br>

        <input type='hidden' name='parentID' value={{category_uri}}>

        <table border='0' cellspacing='5' cellpadding='0'>
            <tr>
                <td>Name</td>
                <td style='padding-left:5px'><input type='text' v-model="new_subcategory_name" size='50' maxlength='60'></td>
            </tr>
            <tr>
                <td>Remarks <span style='color:gray; font-style:italic'>(optional)</span></td>
                <td style='padding-left:5px'><input type='text'  v-model="new_subcategory_remarks" size='50' maxlength='90'></td>
            </tr>
        </table>

        <br>
        <button @click="add_subcategory">Add New Sub-Category</button>
            <span v-if="waiting" class="waiting">Adding the subcategory...</span>
            <span v-bind:class="{'error-message': error, 'status-message': !error }">[[status_message]]</span>
        <br><br>
        <span style='color:gray'><b>OR:</b> add an <a href='/BA/pages/category_manager/{{category_uri}}'><i>existing</i></a> sub-category</span>
    </div>






    <div style='height:170px'></div>     <!-- To extend the main page enough to fit the above floating element -->
    <br><br>

</div>




</div>  <!-- END OF lightbox -->




<!-- Icons (in fixed positions) to expose/hide the editing controls -->
<img v-if="!expose_controls" @click="expose_controls = true"
     class="clickable-icon  fixed-2nd-from-bottom"
     alt="SHOW the Editing Controls (un-lock the page)" title="SHOW the Editing Controls (un-lock the page)"
     src="/BA/pages/static/graphics/screwdriver_unlock.png" width="40" height="40">

<img v-if="expose_controls" @click="expose_controls = false; bulk_operations = false"
     class="clickable-icon  fixed-2nd-from-bottom"
     alt="HIDE the Editing Controls (lock the page)" title="HIDE the Editing Controls (lock the page)"
     src="/BA/pages/static/graphics/lock_6611478_64.png" width="40" height="40">


<!-- Icon (in fixed position) to scroll to top of page -->
<a id="to_top" href="javascript:;" onclick="window.scrollTo(0, 0)">
    <img src="/BA/pages/static/graphics/to_top_80.png" width="40" height="40"
         alt="Scroll to TOP of page" title="Scroll to TOP of page">
</a>


<br>
<div v-if="expose_controls">
    <a href="/BA/pages/md-file/{{category_uri}}" target="_blank">Export to MD file</a>
    <a href="/BA/pages/static-web/{{category_uri}}" target="_blank" style="margin-left:50px">Export to static webpage</a>
</div>
<br><br>



</div>  <!-- END OF scroll-canvas -->

<p style="color:#AAA; text-align: center; margin-top:0">Powered by Brain Annex {{site_data.version}}</p>

</div>	<!--  ~~~~~~~~~~~~~~~~~~~~~  END of Vue root element  ~~~~~~~~~~~~~~~~~~~~~  -->





<!--
    Vue components (and other JS).  This must appear AFTER the Vue-containing elements
  -->
<script src="/BA/pages/static/vue_components/bread_crumbs/bread_crumbs.js"></script>
<script src="/BA/pages/static/vue_components/toc_sidebar/toc_sidebar.js"></script>
<script src="/BA/pages/static/vue_components/category_navbox/category_navbox.js"></script>

<script src="/BA/pages/static/vue_components/content_items/content_items.js"></script>
<script src="/BA/pages/static/vue_components/controls/controls.js"></script>

<script src="/BA/pages/static/modules/vue-clipboard2/vue-clipboard.js"></script>


<!-- PLUGIN-specific Vue components -->
<script src="/BA/pages/static/vue_components/PLUGINS/headers/headers.js"></script>
<script src="/BA/pages/static/vue_components/PLUGINS/images/images.js"></script>
<script src="/BA/pages/static/vue_components/PLUGINS/documents/documents.js"></script>
<script src="/BA/pages/static/vue_components/PLUGINS/notes/notes.js"></script>
<script src="/BA/pages/static/vue_components/PLUGINS/codedocs/codedocs.js"></script>
<script src="/BA/pages/static/vue_components/PLUGINS/site_link/site_link.js"></script>
<script src="/BA/pages/static/vue_components/PLUGINS/recordsets/recordsets.js"></script>
<script src="/BA/pages/static/vue_components/PLUGINS/timer/timer.js"></script>

<script src="/BA/pages/static/vue_components/PLUGINS/records/records.js"></script>
<script src="/BA/pages/static/vue_components/PLUGINS/records/records_linked.js"></script>



<script>
// Instantiation of the ROOT component must come after the definition of the descendant components
new Vue({
    el: '#vue-root',

    delimiters: ['[[', ']]'] ,  // Changing delimiters: requesting double SQUARE brackets, to avoid interfering with Flask



    // ---------------------  DATA  ----------------------

    data: {     // GLOBAL DATA for the whole page (Vue root element).
                // This is the handover of data from Flask to Vue

        registered_plugins: ["n", "i", "h", "cd", "d", "sl", "rs", "timer"],
                                    // "r" not included here, because a generic core one - see plugin_component_name()
                                    // TODO: either pass from the database, or infer from some config file
                                    // IMPORTANT: the items in the list MUST correspond to the folders in
                                    //            flask_modules/pages/static/vue_components/PLUGINS

        content_array: {{content_items | tojson(indent=4)}},
                                    // Array containing objects with the data for all the Content Items on the page
                                    // EXAMPLE: [{pos:0,"uri":"5",schema_code:"h",text:"GENERAL METHODS", class_name: "Header"},
                                    //           {pos:50,"uri":"8",schema_code:"i",basename:"mypix",suffix:"png", class_name: "Image"}
                                    //          ]
                                    // TODO: component-editable fields and non-editable ones ("pos", "uri", "schema_code", "class_name") ought to be treated differently

        expose_controls: false,     // If true, the editing controls of the various Content Items are revealed

        category_uri: {{category_uri | tojson}},    // A string with the URI of the Category featured on this page

        show_left_sidebar: true,    // If true, the the left sidebar (with the Page Contents) is shown; otherwise, collapsed
        show_right_sidebox: true,   // If true, the the left sidebar (with the Category navigation) is shown; otherwise, collapsed

        records_types: {{records_types | tojson}},   // Array of all the names of leaf Classes associated to records

        items_schema_data : {{items_schema_data | tojson }}, // EXAMPLE:
                                                                 // {"Quote": ["quote", "attribution", "notes"],
                                                                 //  "French Vocabulary": ["French", "English", "notes"],
                                                                 //  "Site Link": ["url", "name", "date", "comments", "rating", "read"]}

        bread_crumbs: {{bread_crumbs | tojson}},
                        // EXAMPLE: ["START_CONTAINER", [1, 544, 514], "END_CONTAINER"]

        category_name: {{category_name | tojson}},

        parent_categories: {{parent_categories  | tojson}},

        all_subcategories: {{subcategories | tojson}},
                        // EXAMPLE: [{"uri":"709","name":"English"},{"uri":"708","name":"Italian"},{"uri":"514","name":"French"}]

        siblings_categories: {{siblings_categories | tojson}},
                        // EXAMPLE: [{'name': 'French', 'uri': '514', 'schema_code': 'cat', 'internal_id': 522}]

        all_categories: {{all_categories | tojson}},
                        // EXAMPLE: [{"uri": "1", "name": "HOME", "remarks": "ROOT NODE"}, {"uri": 523, "name": "work", 'pinned': True}]

        next_new_item_uri: -1,      // Auto-increment negative values as URI placeholders for new Content Items being added: -1, -2, ...


        // For bulk operations.  TODO: turn into a Vue component
        bulk_operations: false,     // If true, checkboxes for bulk operations of Content Items are revealed
        checkboxes_selected: [],    // Array of index positions of the Content Items selected for bulk operations
                                    // The order doesn't matter; it will be sorted prior to sending to server
                                    // (note: the sorting will preserve the positional order prior on the page, prior to sending request to server)
                                    // EXAMPLE:  [4, 0, 1, 9, 7, 8]

        group_boundary: null,       // The array index (in the array content_array) of
                                    //      the first or last Content Item selected in a contiguous group
        category_to_move_to: null,  // The uri of the Category to bulk-move the selected Content Items to

        category_input_navigator: null, // Content of INPUT element used for Category navigation
                                        //     (in conjunction with "Awesomplete" module)


        // For the "Add Subcategory" form (TODO: move to a separate component?)
        new_subcategory_name: "",
        new_subcategory_remarks: "",
        status_message: "",          // Message for the user about the status of the last operation (NOT used for "waiting" status)
        error: false,                // Whether the last server communication resulted in error
        waiting: false               // Whether any server request is still pending

    }, // DATA



    // ---------------------  HOOKS  ----------------------

    mounted()
    {
        // If the page is devoid of content and of sub-categories, switch automatically to editing mode
        if (this.is_page_empty)
            this.expose_controls = true;

        // Portion for module Awesomplete.  See: https://projects.verou.me/awesomplete/
        const inputElement = document.getElementById("category_navigator"); // The input element managed by Awesomplete
        console.log(inputElement);

        // Show label but insert value into the input:
        new Awesomplete(inputElement, {
            autoFirst: true,            // The 1st match automatically highlighted  in pop-down menu
            list: this.all_categories,  // Data source
            sort: false,                // Don't perform any sorting (our data source is already sorted!)
            maxItems: 20,               // Max number of matches being shown in pop-down menu

            data: function (item, input) {
                        // Translate our data-source key names ("name" and "uri")
                        // to the key names expected by Awesomplete ("label" and "value", respectively).
                        // If a "remarks" key is also present in the data, incorporate it into the "label",
                        // within square brackets
                        if (item.remarks !== undefined)
                            return { label: item.name + " [" + item.remarks + "]" , value: item.uri };
                        else
                            return { label: item.name, value: item.uri };
            }
        });


        /* Listen for a particular event that will be generated by Awesomplete when
           "The user has made a selection (either via pressing enter or clicking on an item), and it has been applied"
         */
        inputElement.addEventListener("awesomplete-selectcomplete", (event) => {
            //console.log(event);     // Event of type "awesomplete-selectcomplete"
            console.log(`Awesomplete picked (label): ${event.text.label}`);
            console.log(`Awesomplete picked (value): ${event.text.value}`);
            this.category_input_navigator = `LOADING new page: "${event.text.label}"...`;   // This will show inside
                                                                                            // the INPUT element, while the page re-direct
                                                                                            // takes its time
            window.location.href = `/BA/pages/viewer/${event.text.value}`;                  // Re-direct web page
        });

    },



    // ---------------------  COMPUTED  ----------------------

    computed: {
        is_page_empty()
        // Return true if the page is empty of content and of sub-categories; false, otherwise
        {
            if (this.content_array.length == 0 && this.all_subcategories.length == 0)
                return true;
            else
                return false;
        }


    }, // COMPUTED



    // ----------------------------  METHODS  -----------------------------

    methods:  {

        toggle_edit_mode()
        /*  Invoked when the user double-clicks on the page's Category name:
            toggle the page edit mode, and clear any text selected by the double click
         */
        {
            // Toggle the page edit mode
            this.expose_controls = !this.expose_controls;

            // Clear any text selection
            window.getSelection().removeAllRanges();
        },

        clear_checkboxes()
        // Clear all the checkboxes for the bulk operations
        {
            for (let i = 0; i < this.content_array.length; ++i)  {
                let ci = this.content_array[i];
                let uri = ci.uri;
                console.log(`    resetting checkmark for URI "${uri}"`);
                let checkbox_element_arr = this.$refs[uri];         // Pluck out the entry for the specific checkbox HTML element (<INPUT>)
                                                                    // that we're looping over
                //console.log(checkbox_element_arr);                // This reveals an array whose only entry is the <INPUT> element
                let checkbox_element = checkbox_element_arr[0];     // This will be our <INPUT> element
                //console.log(checkbox_element);

                checkbox_element.checked = false;                   // UN-CHECK the box
            }
        },


        reset_checkboxes()
        // Clear all the checkboxes for the bulk operations, and reset all their related variables
        {
            this.clear_checkboxes();

            // Reset all variables related to those checkboxes
            this.checkboxes_selected = [];
            this.group_boundary = null;
        },


        bulk_checkbox_clicked(item, index)
        /* Invoked whenever the user clicks on any of the CHECKBOXES visible while in bulk-edit mode.
            Note that that <INPUT> elements with the checkboxes contain:   v-bind:ref="item.uri"
         */
        {
            // Extract the URI and Class of the Content Item whose checkbox was clicked
            const uri = item.uri;
            const class_name = item.class_name;

            //console.log(`Clicked checkbox for Content Item with URI: '${uri}' from Class '${class_name}'`);

            //console.log(this.$refs);                          // Shows an array whose keys are the uri's of
                                                                // all the various <INPUT> elements that contain v-bind:ref="item.uri"
            const checkbox_element_arr = this.$refs[uri];       // Pluck out the entry for the specific checkbox HTML element (<INPUT>)
                                                                // that invoked this function
            //console.log(checkbox_element_arr);                // This reveals an array whose only entry is the <INPUT> element
            const checkbox_element = checkbox_element_arr[0];   // This will be our <INPUT> element

            const checkbox_status = checkbox_element.checked;   // This will be true if the checkbox is in a selected state (AFTER our click!)
            //console.log(`    checkbox status is: ${checkbox_status}`);

            // Update the array of URI's that are selected for the bulk-update operation
            //console.log(`bulk_checkbox_clicked() BEFORE update - State variable checkboxes_selected (indexes of checkboxes that are marked) : ${this.checkboxes_selected}`);

            if (checkbox_status) {
                console.log(`    new box checked`);   // Note: the switch to checked state happened upon the click, BEFORE we get here
                /*
                if (this.checkboxes_selected.includes(index))  {  // Unexpected scenario
                    alert(`Attempting to select checkbox for Class/URI: '${[class_name, uri]}' more than once; it's recommended to refresh the page and start over`);
                    return;
                }
                */
                if (! this.checkboxes_selected.includes(index))
                    this.checkboxes_selected.push(index);
            }
            else  {
                console.log(`    removing index value ${index}, representing Class/URI pair: '${[class_name, uri]}'`);
                // Remove from this.checkboxes_selected
                var pos = this.checkboxes_selected.indexOf(index);
                if (pos == -1)  {     // Unexpected scenario
                    alert(`Unable to find the index value ${index}, corresponding to checkbox for Class/URI: '${[class_name, uri]}'; it's recommended to refresh the page and start over`);
                    return;
                }
                this.checkboxes_selected.splice(pos, 1);      // Removes 1 element from the array, at the specified `pos` position
            }

            console.log(`bulk_checkbox_clicked() at end - State variable checkboxes_selected (indexes of checkboxes that are marked) : ${this.checkboxes_selected}`);
        },



        contiguous_group(item, index)
        /*  Invoked when user click on a link to select the first or last of a contiguous group of checkboxes (for bulk operations)
            `item` and `index` refer to the Content Item next to the link, and its index position on the page.
         */
        {
            console.log(`Clicking on link next to item of index ${index} for bulk operations.  Item Class name: "${item.class_name}" , URI: "${item.uri}"`);
            //console.log(`Item details:`);
            //console.log(item);
            console.log(`this.group_boundary = ${this.group_boundary}`);

            //console.log(this.$refs);                              // Shows an object whose keys are the uri's of
                                                                    // all the various <INPUT> elements that contain v-bind:ref="item.uri"

            if (this.group_boundary === null)  {
                const uri = item.uri;
                const class_name = item.class_name;
                console.log(`    the link click is resulting in STARTING a contiguous group in index position ${index} for Content Item with URI '${uri}' from Class '${class_name}'`);

                let checkbox_element_arr = this.$refs[uri];           // Pluck out the entry for the specific checkbox HTML element (<INPUT>)
                                                                      // that corresponds to the link we clicked on
                //console.log(checkbox_element_arr);                  // This reveals an array whose only entry is the <INPUT> element
                let checkbox_element = checkbox_element_arr[0];       // This will be our <INPUT> element
                //console.log(checkbox_element);

                //const checkbox_status = checkbox_element.checked;       // This will be true if the checkbox is in a selected state -> IT DOESN'T MATTER HERE!
                //console.log(`    checkbox status is: ${checkbox_status}`);

                // CHECK the corresponding checkbox
                checkbox_element.checked = true;

                // Update the array of URI's that are selected for the bulk-update operation,
                // by adding the [class_name, uri] pair, unless already present
                if (! this.checkboxes_selected.includes(index))
                    this.checkboxes_selected.push(index);

                this.group_boundary = index;        // Make a note of the index of the first group boundary (start or end of the contiguous block),
                                                    // to be used at the next link selection
            }

            else {
                console.log(`    the link click is resulting in **ENDING** contiguous group in index position ${index} for Content Item with URI '${item.uri}' from Class '${item.class_name}'`);
                // Select all Content Items, from index `this.group_boundary` to the `index` argument
                var start_pos = Math.min(this.group_boundary, index);
                var end_pos  =  Math.max(this.group_boundary, index);

                console.log(`    now selecting all checkboxes from index position ${start_pos} to position ${end_pos}`);

                for (let i = start_pos; i <= end_pos; ++i)  {
                    if (i == this.group_boundary)  {
                        console.log(`        skipping the already-handled boundary element of index ${i}`);
                        continue;       // Already handled it when first selected it
                    }

                    let uri = this.content_array[i].uri;
                    let class_name = this.content_array[i].class_name;
                    console.log(`        checking box in index position ${i} for Content Item with URI ${uri} from Class '${class_name}'`);

                    let checkbox_element_arr = this.$refs[uri];           // Pluck out the entry for the specific checkbox HTML element (<INPUT>)
                                                                          // that corresponds to the link we clicked on
                    //console.log(checkbox_element_arr);                  // This reveals an array whose only entry is the <INPUT> element
                    let checkbox_element = checkbox_element_arr[0];       // This will be our <INPUT> element
                    //console.log(checkbox_element);

                    //const checkbox_status = checkbox_element.checked;       // This will be true if the checkbox is in a selected state -> IT DOESN'T MATTER HERE!
                    //console.log(`    checkbox status is: ${checkbox_status}`);

                    // CHECK the corresponding checkbox
                    checkbox_element.checked = true;

                    // Update the array of URI's that are selected for the bulk-update operation
                    if (! this.checkboxes_selected.includes(i))  {
                        this.checkboxes_selected.push(i);
                        console.log(`    index ${i} added to this.checkboxes_selected`);
                    }
                    else
                        console.log(`    index ${i} NOT added to this.checkboxes_selected, because already in it`);
                }

                this.group_boundary = null;    // A fresh start for possible more selections of contiguous boxes
            }
        },



        perform_bulk_operation()
        // Invoked when the user presses the "BULK RE-CLASSIFY" button
        {
            // Make sure that the selection isn't empty  (TODO: the button should be greyed out if no checkboxes are selected)
            if (this.checkboxes_selected.length == 0)  {
                alert("No elements were selected for this bulk operation!  Use the checkboxes to select the elements first");
                return;
            }

            if (!this.category_to_move_to)  {
                alert("No Category was selected for this bulk operation!  Use the pulldown menu to select a Category first");
                return;
            }

            const category_from_uri = this.category_uri;
            const category_to_uri = this.category_to_move_to.uri;
            const category_to_name = this.category_to_move_to.name;

            console.log(`Bulk reclassifying the Content Items in the following index positions:  ${this.checkboxes_selected}`);
            console.log(`    moving them from Category URI '${category_from_uri}' ("${this.category_name}") to URI '${category_to_uri}' ("${category_to_name}")`);

            this.checkboxes_selected.sort();
            console.log(`    checkboxes_selected (sorted) : ${this.checkboxes_selected}`);

            var uri_list_sorted = [];

            for (var index of this.checkboxes_selected) {     // Loop over the list of selected checkboxes
                const {class_name, uri} = this.content_array[index];    // Extract some properties from this Content Item
                // TODO: for now, the class_name isn't being passed to the server
                console.log(`    Readying Content Item  class_name : ${class_name} , uri : ${uri}`);
                uri_list_sorted.push(uri);
            }
            console.log(`    uri_list_sorted : ${uri_list_sorted}`);


            // TODO: in the future, both the URI's and the class names will be sent to the server, as soon as the backend is upgraded

            // Send the request to the server, using a POST
            const url_server_api = "/BA/api/switch_category";
            const post_obj = {items: JSON.stringify(uri_list_sorted),
                              from: JSON.stringify(category_from_uri),
                              to: JSON.stringify(category_to_uri)};
            // TODO: maybe let contact_server() handle the JSON.stringify calls

            console.log(`About to contact the server at ${url_server_api} .  POST object:`);
            console.log(post_obj);

            // Initiate asynchronous contact with the server
            ServerCommunication.contact_server_OLD(url_server_api,
                        {post_obj: post_obj,
                         callback_fn: this.finish_perform_bulk_operation
                        });

            this.waiting = true;        // Entering a waiting-for-server mode
            this.error = false;         // Clear any error from the previous operation
            this.status_message = "";   // Clear any message from the previous operation
        },


        finish_perform_bulk_operation(success, server_payload, error_message, custom_data)
        /* Callback function to wrap up the action of perform_bulk_operation()
           upon getting a response from the server
         */
        {
            console.log("Finalizing the perform_bulk_operation() operation...");

            // Clear all checkmarks.  Note: this must be done BEFORE taking out from the page the eliminated Content Items
            //console.log("Clearing all checkboxes as part of page refresh");
            this.clear_checkboxes();

            if (success)  {     // Server reported SUCCESS
                console.log("    server call was successful");
                this.status_message = `${this.checkboxes_selected.length} Content Items moved to other category`;

                // Refresh the page display by taking out the Content Item that were moved away
                console.log("    updating page by removing items: ", this.checkboxes_selected);
                // Update the page, by ditching the Content Items that were moved away, in REVERSE page order,
                // so that index values will still be correct as Items get taken off the page!
                for (let i = this.checkboxes_selected.length - 1 ; i >= 0  ; --i) { // Loop over the indexes of the checkboxes that were selected (in REVERSE order_)
                    let index = this.checkboxes_selected[i];
                    let {class_name , uri} = this.content_array[index];     // Unpack some properties of this Content Item
                    console.log(`    removing item with URI '${uri}' and Class '${class_name}' from page: array index is ${index}`);
                    this.content_array.splice(index, 1);                    // Deletes 1 array element from the specified index position
                                                                            // (note: the index position of the remaining Items - earlier in
                                                                            //        this.content_array - won't be affected)
                }

                // Reset all variables related to those checkboxes
                this.checkboxes_selected = [];          // Clear the data about the checkboxes that were selected
                this.group_boundary = null;
            }
            else  {                     // Server reported FAILURE
                this.error = true;
                this.status_message = `FAILED operation: ${error_message}`;
            }

            // Final wrap-up, regardless of error or success
            this.waiting = false;      // Make a note that the asynchronous operation has come to an end
        },



        adjust_left_sidebar(state)
        // If state is true, expand the left sidebar; otherwise, collapse it
        {
            //console.log(`Root element received signal to adjust the left sidebar, with state ${state}`);
            this.show_left_sidebar = state;
        },


        adjust_right_sidebox(state)
        // Adjust the collapse/expansion of the right sidebox, based on the requested state: true = expanded; false = collapsed
        {
            console.log(`Root element received signal to adjust the right sidebox, with state ${state}`);
            this.show_right_sidebox = state;
        },



        get_schema_data(item)
        /*  Return a list of the field names (Properties), in their schema order, for the given Content Item.
            EXAMPLE:  ['quote', 'attribution', 'notes']
            If the data is missing, return an empty array instead
         */
        {
            //if (item.schema_code != "r")
                //return [];                      // Nothing is being done for non-record Content Items (at least for now)

            const item_class = item.class_name;

            return this.items_schema_data[item_class] || [];     // If the requested key doesn't exist, return an empty array instead
                                                                  // TODO: if key is missing, query the server
        },


        add_subcategory()
        // Create a new sub-category for the current Category
        {
            const category_uri = this.category_uri;
            console.log(`Adding new sub-category: category_uri: ${category_uri}, subcategory name: ${this.new_subcategory_name} , remarks: ${this.new_subcategory_remarks}`);
            if (this.new_subcategory_name == "")  {
                alert("Must enter a Subcategory name");
                return;
            }

            // Send the request to the server, using a POST
            const url_server_api = "/BA/api/add_subcategory"
            // Compose the body of the POST to send to the server
            const post_obj = {category_uri: category_uri,
                              subcategory_name: this.new_subcategory_name,
                              subcategory_remarks: this.new_subcategory_remarks};

            // Initiate asynchronous contact with the server
            this.waiting = true;        // Entering a waiting-for-server mode
            this.error = false;         // Clear any error from the previous operation
            this.status_message = "";   // Clear any message from the previous operation
            ServerCommunication.contact_server_OLD(url_server_api,
                                               {post_obj: post_obj, callback_fn: this.finish_add_subcategory});
        },

        finish_add_subcategory(success, server_payload, error_message)
        /*  Callback function to wrap up the action of add_subcategory() upon getting a response from the server.
            If a new Subcategory is successfully added, the server_payload will contain the newly-assigned URI
         */
        {
            console.log("Finalizing the Add Subcategory operation...");
            if (success)  {     // Server reported SUCCESS
                this.status_message = `New sub-category successfully added (assigned URI '${server_payload}')`;
                // Update the data of the root component, to refresh some displays
                let new_subcategory = {uri: server_payload, name: this.new_subcategory_name};
                this.all_subcategories.push(new_subcategory);
                this.all_categories.push(new_subcategory);      // TODO: sort alphabetically
            }
            else  {             // Server reported FAILURE
                this.error = true;
                this.status_message = `FAILED addition of new Sub-category`;
            }

            // Final wrap-up, regardless of error or success
            this.waiting = false;      // Make a note that the asynchronous operation has come to an end
            // Clear up the form
            this.new_subcategory_name = "";
            this.new_subcategory_remarks = "";

        }, // finish_add_subcategory



        cancel_edit(item)
        {
            console.log(`Root module received signal to abort editing operation for item '${item.schema_code}' , uri ${item.uri} , pos ${item.pos}`);
            if (item.uri == -1)  {
                // If we're aborting the edit of a new Content Item, delete it from the page
                index = this.locate_item_pos(item.schema_code, item.uri, item.pos);
                console.log(`Aborting the edit of a NEW Content Item, whose index position on the page is ${index}`);
                this.content_array.splice(index, 1);    // It modifies the array, to take out 1 element in position index
            }
        },



        insert_new_item_after(item, {schema_code, class_name})
        /*  Add a new Content Item of the specified type, placed after the specified Item
         */
        {
            //console.log(item);
            console.log(`In root component, insert_new_item_after()`);
            console.log(`    Insert after Item URI '${item.uri}' of class '${item.class_name}'. New item - schema_code: '${schema_code}', class_name: '${class_name}'`);

            this.create_new_item_after(item.uri, item.class_name, schema_code, class_name);
        },


        create_new_item_after(insert_after_uri, insert_after_class, schema_code, class_name)
        /*  Create an empty new record (JS object), with the given `schema_code` and `class_name`,
            to be placed after the specified Content Item on the current Category-viewer page.
            Insert the newly-created record in the appropriate location on the global `this.content_array` ;
            this insertion will trigger a Vue re-draw across the page and its components.
         */
        {
            console.log(`In root component, create_new_item_after().  insert_after_uri: '${insert_after_uri}' | insert_after_class: '${insert_after_class}' | schema_code: '${schema_code}' |  class_name: '${class_name}'`);

            const insert_after_uri_index = this.locate_item_simplified(insert_after_uri, insert_after_class);
            console.log(`    Content Item located in position ${insert_after_uri_index}`);

            if (insert_after_uri_index == -1)  {
                alert("Unable to locate the element after which to insert. Maybe a change was made on a separate tab...  Try refreshing the page");
                return;
            }

            // Assemble the data for a new Content Item.
            // Using an auto-incremented negative number as a temporary URI is a convention to indicate a NEW Content Item
            if (class_name)     // If a class name was passed, store it
                blank_record = {uri: this.next_new_item_uri, schema_code: schema_code, class_name: class_name, insert_after_uri: insert_after_uri, insert_after_class: insert_after_class};
            else  {               // No class name was provided.  TODO: obsolete - this branch no longer in use
                blank_record = {uri: this.next_new_item_uri, schema_code: schema_code, insert_after_uri: insert_after_uri, insert_after_class: insert_after_class};
                alert("create_new_item_after(): adding new Content Item that lacks a Class name!");
            }

            this.next_new_item_uri -= 1;            // Auto-increment, towards more negative numbers

            // Insert the newly-created record after the specified existing element.  This change will be detected by Vue,
            // and will cause the insertion of a new 'vue-content-items' component
            this.content_array.splice(insert_after_uri_index + 1, 0, blank_record);

            // Note: the new Content Item will now appear in editing mode in its handler Vue component,
            //       but not yet added to the database; it will be the Vue component's responsibility to save it,
            //       or cancel the operation

        }, // create_new_item_after



        add_new_item_at_bottom(schema_code, class_name)
        /*  Add a new Content Item of the specified type,
            placed at the bottom of the page (past the last Item)
         */
        {
            console.log(`In root component, add_new_item_at_bottom().  Adding at the bottom of page new Content Item of type '${schema_code}' | class_name: '${class_name}'`);

            // Assemble the data for a new Content Item.  Using a negative number as a temporary URI is a convention to indicate a NEW Content Item
            if (class_name)   // If a class name was passed, store it
                blank_record = {uri: this.next_new_item_uri, schema_code: schema_code, class_name: class_name, insert_after_uri: "BOTTOM"};
            else {            // No class name was provided.  TODO: obsolete - this branch no longer in use
                blank_record = {uri: this.next_new_item_uri, schema_code: schema_code, insert_after_uri: "BOTTOM"};
                alert("add_new_item_at_bottom(): adding new Content Item that lacks a Class name");
            }

            this.next_new_item_uri -= 1;            // Auto-increment, towards more negative numbers

            this.content_array.push(blank_record);  // Insert a new blank Item at the end of the page's Content Items

        }, // add_new_item_at_bottom



        delete_content_item(item)
        // Delete from the page and from the database the specified Content Item
        {
            console.log(`delete_content_item(): Root element received signal to delete content item of Class '${item.class_name}' , uri '${item.uri}'`);
            const index = this.locate_item_simplified(item.uri, item.class_name);
            console.log(`delete_content_item(): Content item located in position ${index}`);

            if (index == -1)  {
                alert("Unable to locate the Item to delete. Maybe a change was made on a separate tab...  Try refreshing the page");
                return;
            }

            url_server = `/BA/api/delete/${item.uri}/${item.class_name}`;
            ServerCommunication.contact_server_OLD(url_server, {callback_fn: this.finish_delete, custom_data: index});

        },  // delete_content_item()

        finish_delete(success, server_payload, error_message, index)
        // Callback function to wrap up the action of delete_content_item() upon getting a response from the server
        {
            console.log("Finalizing the deleting operation...");
            if (success)  {     // Server reported SUCCESS
                console.log(`    Removing from page the element with index ${index}`);
                this.content_array.splice(index, 1);  // It modifies the array, to take out 1 element in position index
            }
            else  {             // Server reported FAILURE
                alert("The server could not delete the Content Item. Perhaps it was deleted on another tab... Try saving your work and reloading the page");
            }

        }, // finish_delete



        move_up_content_item(item)
        //
        {
            const schema_code = item.schema_code;
            const uri = item.uri;

            console.log(`Root element received signal to move UP the content item of type '${schema_code}' , uri ${uri}`);

            const number_items = this.content_array.length;

            if (number_items == 1)  {
                alert("There is only 1 item on the page!  No action taken");
                return;
            }

            const i = this.locate_item(schema_code, uri);     // Locate the specified Content Item in the array of Content Items

            if (i == -1)  {  // Not found
                alert(`Item type '${schema_code}' , id ${uri} NOT found. Maybe was deleted in another browser tab? No action taken`);
                return;
            }
            if (i == 0)  {
                alert("Item is already at the top: no action taken");
                return;
            }

            // Request the server to perform the operation on the data
            const swap_uri = this.content_array[i-1].uri;       // The ID of the Item that we're swapping with
            const url_server = `/BA/api/swap/${uri}/${swap_uri}/${this.category_uri}`;
            console.log(url_server);

            ServerCommunication.contact_server_OLD(url_server, {callback_fn: this.finish_move_up, custom_data: i});

        }, // move_up_content_item


        finish_move_up(success, server_payload, error_message, i)
        // Callback function to wrap up the action of move_up_content_item() upon getting a response from the server
        {
            console.log("Finalizing the move_up operation...");
            if (success)  {     // Server reported SUCCESS
                // Swap the position of the current Item with the one before it
                // Using Vue.set for the array operation to be "reactive" on the UI
                const old_value = this.content_array[i-1];                  // save item above
                Vue.set(this.content_array, i-1, this.content_array[i]);    // the item below moves up
                Vue.set(this.content_array, i, old_value);                  // (the saved) item above moves below
            }
        }, // finish_move_up



        move_down_content_item(item)
        //
        {
            const schema_code = item.schema_code;
            const uri = item.uri;

            console.log(`Root element received signal to move DOWN the content item of type '${item.schema_code}' , id ${item.uri}`);

            const number_items = this.content_array.length;

            if (number_items == 1)  {
                alert("There is only 1 item on the page!  No action taken");
                return;
            }

            const i = this.locate_item(schema_code, uri);     // Locate the specified Content Item in the array of Content Items

            if (i == -1)  {  // Not found
                alert(`Item type '${schema_code}' , id ${uri} NOT found. Maybe was deleted in another browser tab? No action taken`);
                return;
            }
            if (i == number_items - 1)  {
                alert("Item is already at the bottom: no action taken");
                return;
            }

            // Request the server to perform the operation on the data
            const swap_uri = this.content_array[i+1].uri;       // The ID of the Item that we're swapping with
            const url_server = `/BA/api/swap/${uri}/${swap_uri}/${this.category_uri}`;
            console.log(url_server);

            ServerCommunication.contact_server_OLD(url_server, {callback_fn: this.finish_move_down, custom_data: i});
            //ServerCommunication.contact_server_TEXT(url_server, "", this.finish_move_down, i);

        }, // move_down_content_item


        finish_move_down(success, server_payload, error_message, i)
        // Callback function to wrap up the action of move_up_content_item() upon getting a response from the server
        {
            console.log("Finalizing the move_down operation...");
            if (success)  {     // Server reported SUCCESS
                // Swap the position of the current Item with the one after it
                // Using Vue.set for the array operation to be "reactive" on the UI
                const old_value = this.content_array[i+1];                  // save item below
                Vue.set(this.content_array, i+1, this.content_array[i]);    // the item above moves down
                Vue.set(this.content_array, i, old_value);                  // (the saved) item below moves above
            }
        }, // finish_move_down



        absorb_item_updates(item, new_data)
        /* Update the appropriate entry in this.content_array, with the new data passed by a component
           (generally done at the end of an update on the server).

           item:       pre-edit record
           new_data:   post-edit record

           Note that the values of the special key "uri" on `new_data` will only appear
           (and differ from the corresponding field on `item`)
           if this is a newly-created Content Item,
           which was tentatively assigned an autoincr negative value as temp uri.

           The special keys "schema_code" and "pos" are not changed.

           EXAMPLE of `item` and `new_data`, for a NEWLY-CREATED item:
               item:     {uri: -2,
                          schema_code: "h", class_name: "Header", pos: -12}
               new_data: {uri: "h-243",
                          text: "Some Header"}    [Notice: no control fields, except for `uri`]
         */
        {
            console.log("In absorb_item_updates()");
            console.log(`    Original data of Content Item being updated:`);
            console.log(item);

            const old_uri = item.uri;               // This will be a negative number if it was a temporary value for a newly-created Content Item

            const schema_code = item.schema_code;   // This will never be affected by edits
            const class_name = item.class_name;     // This will never be affected by edits

            console.log(`    Root element received signal to UPDATE the Content Item that originally had uri: ${old_uri}`);

            console.log(`    Data for the update:`);
            console.log(new_data);

            var uri = old_uri;

            if (old_uri < 0)  {
                console.log(`    A temporary URI of ${old_uri} is being replaced by the newly-assigned permanent URI '${new_data.uri}'`);
                uri = new_data.uri;
            }
            else if (new_data.uri !== undefined  &&  new_data.uri != old_uri)  {
                console.error(`    Unexpected attempt to update a permanent URI ('${old_uri}'), with a different value ('${new_data.uri}')`);
                alert("Attempting to update a permanent URI on the display.  Save your work and refresh the page");
                return;
            }

            // Locate the Content Item to update
            const index = this.locate_item(schema_code, old_uri);         // TODO: perhaps switch to internal dbase ID's

            if (index == -1)  {    // If the Item is not found on the page
                console.log(`    Failed to locate Content Item with schema_code '${schema_code}', uri '${old_uri}'`);
                alert("Unable to update the display.  Save your work and refresh the page");
                return;
            }

            // Bring the frontend up-to-date with the new data

            let updated_record = Object.assign({}, new_data);      // Start with a clone of the record with the new data
            // This object will replace the element in content_array at our index position
            // (further below, we do a complete array element replacement for Vue reactivity)

            // Restore the special control keys "schema_code" and "class_name"
            // (because they were NOT returned by the `new_data` object that just got cloned)
            updated_record["schema_code"] = schema_code;
            updated_record["class_name"] = class_name;

            // Also set (in the case of new items) or restore (in the case of existing items) the control field "uri"
            updated_record["uri"] = uri;

            // Note about the special key "pos":
            //      1) existing records will have a value not changed thru edits (a separate mechanism is used to reposition items)
            //      2) newly-created Items will lack it; currently, it's created in the server, but not returned to the plugin components
            //                         (TODO: this current situation seems to create problems when attempting to cancel the creation of a new Item)

            if ("pos" in item)
                updated_record["pos"] = item.pos;

            if ("insert_after_uri" in updated_record)
                delete updated_record.insert_after_uri;     // Ditch ("insert_after_uri" is a temporary value, not to be saved)

            if ("insert_after_class" in updated_record)
                delete updated_record.insert_after_class;   // Ditch ("insert_after_class" is a temporary value, not to be saved)


            console.log(`   Updating the Content Item found in content_array at index: ${index}, with the following record:`);
            console.log(updated_record);

            Vue.set(this.content_array, index, updated_record);     // Vue-reactive change (affecting the UI)
                                                                    // in the specified element of this.content_array

        }, // absorb_item_updates



        absorb_updates_existing_item(new_data)
        /* Update the appropriate entry in this.content_array, with the new data passed by a component
           (generally done at the end of an update on the server.)

           NOT to be used for newly-added records: use absorb_item_updates() for those.
           
           new_data: object containing the special keys "uri" and "schema_code" (TODO: later replace with the internal_dbase_id),
                     used to identify the entry in this.content_array,
                     plus keys/values will all the other properties to update.  
                     Unaffected fields aren't expected to be included (but no harm if they are.)
                     EXAMPLE: {uri: '5622', schema_code: 'r', English: 'Woman', German: 'Frau'}
         */
        {
            console.log("In absorb_updates_existing_item()");
            const schema_code = new_data.schema_code;
            const uri = new_data.uri;

            console.log(`    Root element received signal to UPDATE the Content Item of type '${schema_code}' , with original uri '${uri}'`);
            console.log(`    Data for the update:`);
            console.log(new_data);

            const index = this.locate_item(schema_code, uri);         // TODO: switch to internal ID's

            if (index == -1)  {    // If the Item is not found on the page
                console.log(`    Failed to locate schema_code ${schema_code}, uri '${uri}'`);
                alert("Unable to update the display.  Save your work and refresh the page");
            }

            // Bring the frontend up-to-date with the new data
            //console.log(`   Updating the Content Item found in content_array at index: ${index}`);


            let updated_record = Object.assign({}, this.content_array[index]);      // Start with a clone of the Content Item object
                                                                                    // (to allow for a complete record replacement for Vue reactivity)

            // Update all attributes, except "uri" and "schema_code", 
            // in the object that will replace the element in content_array at our index position
            for (key in new_data)  {    // Loop over all the keys in the object
                if (key != "uri"  &&  key != "schema_code")  {
                    let new_value = new_data[key];
                    if (new_value == "")  {
                        //console.log(`    Ditching the field '${key}'`);
                        delete updated_record[key];
                    }
                    else  {
                        //console.log(`    Updating field '${key}' with new value '${new_value}'`);
                        updated_record[key] = new_value;
                    }
                }
            }

            Vue.set(this.content_array, index, updated_record);     // Vue-reactive change (affecting the UI)
                                                                    // in the specified element of this.content_array

        }, // absorb_updates_existing_item



        relocate_content_item(item, where_to)
        /*  (At the request of another component) Relocate the specified Item within the page, to be placed after specified position,
            and inform the server of this operation.
            Note: where_to is a 1-based index of Content Items on the page; by our convention, 0 means "move to top"
         */
        {
            const schema_code = item.schema_code;
            const uri = item.uri;

            console.log(`Root element received signal to RELOCATE the content item of type '${item.schema_code}' , id ${item.uri} to just after the ${where_to}-th entry, within category ${this.category_uri}`);

            const number_items = this.content_array.length;

            if (number_items == 1)  {
                alert("There is only 1 item on the page!  No action taken");
                return;
            }

            const i = this.locate_item_simplified(uri, item.class_name);     // Locate the specified Content Item in the array of Content Items

            if (i == -1)  {  // Not found
                alert(`Item type '${schema_code}' , id ${uri} NOT found. Maybe was deleted in another browser tab? No action taken`);
                return;
            }

            status = this.reposition_content(i, where_to);

            if (!status)  {
                alert("The move operation failed.  Refresh the page and try again");
                return;
            }

            // Request the server to perform the operation on the database
            const url_server = `/BA/api/reposition/${this.category_uri}/${uri}/${where_to}`;
            console.log(url_server);

            ServerCommunication.contact_server_OLD(url_server, {callback_fn: this.finish_relocate_content_item, custom_data: i});

        }, // relocate_content_item



        finish_relocate_content_item(success, server_payload, error_message, i)
        // Callback function to wrap up the action of finish_relocate_content_item() upon getting a response from the server
        {
            console.log("Finalizing the finish_relocate_content_item operation...");
            if (!success)  {     // Server reported FAILURE
                alert("The server could not move the Content Item. Perhaps items were repositioned on another tab.  Save your work and reload the page");
            }
        }, // finish_relocate_content_item



        reposition_content(index_of_moved_item, move_after_n)
        /*  Relocate the Item (specified by its index) within the page, to be placed after the n-th item.
            Return true if successful, or false otherwise.
            IMPORTANT: index_of_moved_item is zero-based, while move_after_n starts at 1 (0 means "move to top")
         */
        {
            if (index_of_moved_item < 0 || index_of_moved_item >= this.content_array.length) {
                console.error(`index_of_moved_item ${index_of_moved_item} is out of bounds.  Expected range is [0-${this.content_array.length - 1}]`);
                return false;
            }

            if (move_after_n < 0 || move_after_n > this.content_array.length) {
                console.error(`move_after_n ${move_after_n} is out of bounds.  Expected range is [0-${this.content_array.length}]`);    // Note it's 1 longer than the range of index_of_moved_item
                return false;
            }

            if (move_after_n == index_of_moved_item) {
                console.error(`Attempting to reposition to same location: index_of_moved_item and move_after_n are equal (both ${move_after_n})`);
                return false;
            }

            console.log(`Relocate the ${index_of_moved_item}-th Item on the page, to be moved after position ${move_after_n}`);

            const being_moved = this.content_array[index_of_moved_item];    // The object with the data of the Content Item being moved

            this.content_array.splice(move_after_n, 0, being_moved);        // Insert it at the given position

            if (move_after_n < index_of_moved_item)
                index_of_moved_item += 1;                                   // If the insertion took place before the element to take out, adjust its index

            this.content_array.splice(index_of_moved_item, 1);              // Take it out from the array of Content Items

                                                                            // (Note: Vue automatically detects array changes done with splice)
            return true;

        }, // reposition_content



        locate_item_simplified(uri, class_name)
        /*  Locate the specified Content Item in the array of Content Items.
            The item is identified by its uri.
            If found, return its index in the array (an int >= 0); otherwise, return -1
            (No check is done as to whether there might be more than one match; the first one is returned.)
            TODO: for consistency, the order should be reversed, i.e. class_name, uri
            TODO: replace it with call to Utilities.find_item_by_uri(uri, this.content_array);
                  also include script src="/BA/pages/static/js/utilities.js"
         */
        {
            console.log(`Attempting to locate content item with uri '${uri}' and class_name '${class_name}'`);

            const number_items = this.content_array.length;

            for (var i = 0; i < number_items; i++) {
                if (this.content_array[i].uri == uri  &&  this.content_array[i].class_name == class_name)
                    return i;          //  Found it
            }

            return -1;    // Didn't find it
        },

        locate_item(schema_code, uri)
        /*  TODO: maybe phase out in favor of locate_item_simplified()
            TODO: consider using Lodash library (https://lodash.com/docs/4.17.15#findIndex)

            Helper function, to locate the specified Content Item in the array of Content Items.
            The item is identified by its schema_code and uri.  (Note: schema_code is redundant.)
            If found, return its index in the array; otherwise, return -1
            (No check is done as to whether there might be more than one match; the first one is returned.)
         */
        {
            //console.log(`Attempting to locate content item of type '${schema_code}' , id ${uri}`);

            const number_items = this.content_array.length;

            for (var i = 0; i < number_items; i++) {
                if (this.content_array[i].schema_code == schema_code  &&  this.content_array[i].uri == uri)
                    return i;          //  Found it
            }

            return -1;    // Didn't find it
        },


        locate_item_pos(schema_code, uri, pos)
        /*  Same as locate_item(), but also requiring a match on position.  ONLY USED TO DROP NEW ITEMS WHOSE ADDITION GOT CANCELLED
         */
        {
            //console.log(`Attempting to locate content item of type '${schema_code}' , uri ${uri}, pos ${pos}`);

            const number_items = this.content_array.length;

            for (var i = 0; i < number_items; i++) {
                if (this.content_array[i].schema_code == schema_code  &&
                    this.content_array[i].uri == uri  &&
                    this.content_array[i].pos == pos)
                    return i;          //  Found it
            }

            return -1;    // Didn't find it
        }


    } // METHODS

});
</script>


</body>
</html>