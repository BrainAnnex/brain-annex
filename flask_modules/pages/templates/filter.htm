<!DOCTYPE html>
{#  Forms to initiate searches, including full-text searching

    Flask-passed parameters:

        site_data
        current_page
        username

        all_labels          List of all the node labels present in the database
                                EXAMPLE: ["my_label_1", "my_label_2"]

        all_categories      A list of dicts.  Note that the 'remarks' and 'pinned' keys may or may not be present.
                                EXAMPLE:
                                    [{"uri": "1",   "name": "HOME", "remarks": "ROOT NODE"},
                                     {"uri: "123",  "name": "Calculus"},
                                     {"uri": "523", "name": "Work at Acme", "pinned": True}]
 #}

<html lang="en">
<head>
    <title>Filter</title>

    <link type="text/css" rel="stylesheet" href="/BA/pages/static/css/brain_annex.css">

    <link type="text/css" rel="stylesheet" href="/navigation/static/horiz_status_bar.css">
    <link type="text/css" rel="stylesheet" href="/navigation/static/navbar_top.css">

    <link type="text/css" rel="stylesheet" href="/BA/pages/static/css/node_explorer.css">
    <link type="text/css" rel="stylesheet" href="/BA/pages/static/css/record_navigator.css">
    <link type="text/css"  rel="stylesheet" href="/BA/pages/static/vue_components/multiselect/multiselect.css">

    <link type="text/css" rel="stylesheet" href="/BA/pages/static/css/control_panels.css">

    <!-- JavaScript -->
    <script src="/BA/pages/static/Vue2/vue2.js"></script>       <!-- Vue.js (version 2) -->
    <script src="/BA/api/static/server_communication.js"></script>
</head>

<body>

{# HORIZONTAL STATUS BAR (fixed at the top) #}
{% include "horiz_status_bar.htm" %}

<div class="menu-wrapper">
    {# TOP NAVIGATION BAR #}
    {% include "navbar_top.htm" %}
</div>


<h2>Search Notes and Documents</h2>
<i>(retrieve anything that includes ALL the words below; common words ignored)</i><br><br>

<div class="content-block">
    <div class="content-block-title">Search</div>

    <form method='GET' action='search'>
        <br>
        <input type='text' name='words'  size="100" maxlength="225" placeholder="Enter all the words to search for">
        <br><br><br>

        <select name='search_category'  style='font-size:14px'>
            <option value=''>[OPTIONALLY, select Category to restrict search under]</option>
            {% for category in all_categories %}
            <option value='{{category.uri}}'>
                {{category.name}}
                {% if category.remarks %} [{{category.remarks}}] {% endif %}
            </option>
            {% endfor %}
        </select>

        <input type="submit" value="SEARCH">
    </form>

</div>





<br><br><br>

<h2>Search the Database Nodes</h2>


<div id="vue-root-1">   <!-- Container for VUE COMPONENTS : the ROOT of the components below -->






<div class='form-box'>
    <span class='title'>SELECT THE CRITERIA</span><br><br>

    <table border='0' cellspacing='5' cellpadding='0'>
        <!--
        <tr>
            <td>Class Name</td><td><input type="text" size="40" v-model="class_name"></td>
        </tr>
        -->
        <tr>
            <td>Label Name</td>

            <td>
                <select v-model="label" @change='lookup_fields'>
                    <option disabled value=''>[Choose a label]</option>
                       <option v-for="label in {{all_labels}}" v-bind:value="label">
                       [[label]]
                       </option>
                </select>
                <span style="color: gray">REQUIRED</span>
            </td>

        </tr>

        <tr>
            <td style="border-left: 2px solid green; padding-left: 3px;">Key Names</td>
            <td style="padding-top: 10px">
                <!--SELECTED: [[selected_fields]]<br>-->
                <vue-multiselect
                    v-model="selected_fields"
                    v-bind:options=available_fields
                    placeholder="Select option (Pick a label FIRST)"
                    v-bind:multiple="true">
                </vue-multiselect>
                <span class="form-comment" style="display: block; text-align: right">If more than 1 selected from menu, an implicit OR</span>
            </td>
        </tr>

        <tr>
            <td style="border-left: 2px solid green; padding-left: 3px;">Key Name (typed in)</td><td><input type="text" size="50" v-model="key_name">
            <span class="form-comment">If provided, it takes priority over values from menu</span>
            </td>
        </tr>

        <tr>
            <td style="padding-top:20px">Key Value</td>
            <td style="padding-top:20px"><input type="text" size="50" v-model="key_value">
            <span class="form-comment">If text, implicit "Contains" (sub-string)</span>
            <input type="checkbox"  v-model="case_sensitive" style="margin-left:15px">Match Case?
            </td>
        </tr>
        <tr>
            <td>ORDER BY</td><td><input type="text" size="50" v-model="order_by">
            <span class="form-comment">Comma-separated values, each optionally followed by DESC</span>
            </td>
        </tr>
        <tr>
            <td>SKIP</td><td><input type="text" size="2" v-model="skip"></td>
        </tr>
        <tr>
            <td>LIMIT</td><td><input type="text" size="2" v-model="limit"></td>
        </tr>
    </table>

    <br>
    <button @click="submit_query" v-bind:disabled="!label">
        Submit query <span v-if="!label">(MUST pick a label first)</span>
    </button>

</div>  <!-- class='form-box' -->

<p>
    <span v-if="waiting" class="waiting">Retrieving the data...</span>
    <span v-bind:class="{'error-message': error, 'status-message': !error }">[[status_message]]</span>
</p>



<!--  ***  QUERY RESULTS  ***  -->

<p style="color: #888; margin-top:30px; margin-bottom:0">Query result:</p>

<div style="border:1px solid #DDD; padding:10px; background-color: #f4f4f4">

    <p v-if="recordset_summary && (recordset_array.length === 0)" style="color: gray">
        NO ITEMS FOUND
    </p>


    <!--  For each located item  -->
    <p v-for="(item, index) in recordset_array"
                style="border: 1px solid #CCC; padding-bottom: 5px; padding-left: 3px; margin-bottom:2px; margin-top:3px;
                       background-color: white"
                v-bind:style="{'margin-left': item.controls.indent * 50 + 'px'}">

        <!--  Eye icon, to hide the record  -->
        <span style="color:#d0d0d0">[[item.controls.record_id]] </span>
        <img src="/BA/pages/static/graphics/eye_16_173007.png"
             @click="hide_record(item, index, true)" class="clickable-icon"
             v-bind:title="'HIDE record (index ' + index + ')'"   alt="HIDE"
        >
        &nbsp;

        <!-- If applicable, show the record's parentage (i.e. link name/direction to a record above) -->
        <template v-if="item.controls.parent_record_id !== null">
            <span v-if="item.controls.parent_dir == 'OUT'"
                class="subrecord-out"
                v-bind:title="'Neighbor of node ' + item.controls.parent_record_id + ' by the OUT-bound link `' + item.controls.parent_link + '`'"
                style="display: inline-block; margin-right:10px">
                <img src='/BA/pages/static/graphics/20_outbound_4619660.png'>
                [[item.controls.parent_link]]
            </span>
            <span v-else
                class="subrecord-in"
                v-bind:title="'Neighbor of node ' + item.controls.parent_record_id + ' by the IN-bound link `' + item.controls.parent_link + '`'"
                style="display: inline-block; margin-right:10px">
                <img src='/BA/pages/static/graphics/20_inbound_4619661.png'>
                [[item.controls.parent_link]]
            </span>
        </template>

        <!-- Display the data record (with all its fields) -->
        <template v-for="(val, key) in item.data">
            <span v-if="key == 'node_labels'" style="color:brown; font-size:14px; font-weight:bold; font-family: Arial, sans-serif;">LABELS: </span>
            <span v-else style="color:grey; font-size:12px" class="monospace">[[key]]: </span>

             `<span style="background-color: rgb(251, 240, 240)">[[val]]</span>` <span style="color:brown; font-weight: bold">|| </span>
        </template>

        &nbsp;

        <span v-if="item.controls.expand" >

            <template v-for="link in item.controls.links">  <!-- Show all the links (inbound and outbound) -->

                <span v-if="link[1]=='IN'" @click="toggle_linked_records(item, link[0], index, 'IN')"
                      class="clickable-icon relationship-in"
                      v-bind:title="'Show/Hide ' + link[2] + ' IN-bound link(s) `' + link[0] + '`'"
                >
                    <!-- Inbound link : show the number of links, an icon, and the link's name -->
                    [[ link[2] ]]
                    <img src="/BA/pages/static/graphics/20_inbound_4619661.png" alt="Show/Hide IN-bound links">
                    [[ link[0] ]]
                </span>

                 <span v-else @click="toggle_linked_records(item, link[0], index, 'OUT')"
                      class="clickable-icon relationship-out"
                      v-bind:title="'Show/Hide ' + link[2] + ' OUT-bound link(s) `' + link[0] + '`'"
                 >
                    <!-- Outbound link : show the number of links, an icon, and the link's name -->
                    [[ link[2] ]]
                    <img src="/BA/pages/static/graphics/20_outbound_4619660.png" alt="Show/Hide OUT-bound links">
                    [[ link[0] ]]
                </span>

                &nbsp;
            </template>


            <!-- Arrow to shrink the record, to hide the links -->
            <img src="/BA/pages/static/graphics/arrow_down_22_79479.png" title="Hide LINKS" alt="Hide LINKS"
              @click="toggle_links(item, index)"
              class="clickable-icon" style="background-color:black">
        </span>

        <!-- Arrow to expand the record, to show the links -->
        <img v-else src="/BA/pages/static/graphics/arrow_right_22_79650.png" title="Show LINKS" alt="Show LINKS"
             @click="toggle_links(item, index)"
             class="clickable-icon" style="background-color:black">

    </p>


    <!-- Summary of search -->
    <p v-if="recordset_summary" style="color:gray">
        <b>[[recordset_array.length]] records found</b> (out of a total of [[recordset_summary]] node(s) with the requested label `[[label]]`)
    </p>

</div>


</div>	<!--  ~~~~~~~~~~~~~~~~~~~~~  END of Vue root element "vue-root-1"  ~~~~~~~~~~~~~~~~~~~~~  -->





<!-- Vue-related code (and other JS).  This must appear AFTER the Vue-containing elements.
     The type="module" must be for imported scripts that in turn contain imports!  In that case,
     the script below must handle both the JS import and the instantiation of Vue, to make sure
     that the former is completed first -->

<script type="module">
// Import the JS module (it will register the component globally - and it will be completed
// prior to the instantiation of Vue, below)
import '/BA/pages/static/vue_components/multiselect/multiselect.js';


// Instantiation of the Vue object (ROOT component) must come last
new Vue({
    el: '#vue-root-1',              // There should be a DIV in the HTML code with this string as id

    delimiters: ['[[', ']]'] ,      // Changing delimiters: requesting double SQUARE brackets for Vue, to avoid interfering with Flask

    data: {     // Global data for the whole page (Vue root element).  This is the handover of data from Flask to Vue

        class_name: "",             // TODO: Not currently used
        label: "",
        key_name: "",
        key_value: "",
        case_sensitive: false,      // Applicable to text-based searches
        order_by: "",
        skip: 0,
        limit: 10,

        next_record_id: 0,

        recordset_summary: "",      // The total count (total number of nodes with requested label in dbase)
        recordset_array: [],        // Array of dicts, with one entry per record returned by the search
                                    //      Each entry is an object with 2 keys: "controls" and "data":
                                    //
                                    //      * "controls" is an array of dicts, with the following keys:
                                    //                      "record_id" (int)
                                    //                      "parent_record_id" (int)
                                    //                      "parent_link" (str)
                                    //                      "parent_dir" (str: "IN" or "OUT")
                                    //                      "expand" (bool)
                                    //                      "indent" (int)
                                    //                      "links" (array of triples: name, "IN"/"OUT", count)
                                    //                      "pos" (int) : meant to hold TEMPORARY values
                                    //
                                    //      * "data" is an array of dicts contains all the field names and values
                                    //            returned from the database query

        available_fields: [],       // Array of field names for dbase node
        selected_fields: null,      // Used by the "multiselect" Vue component

        status_message: "",         // Message for the user about the status of the last operation (NOT used for "waiting" status)
        error: false,               // Whether the last server communication resulted in error
        waiting: false              // Whether any server request is still pending
    },


    // ---------------------  METHODS  ----------------------

    methods:  {

        toggle_links(record, record_index)
        /*  Show/Hide an inline summary of the available links from/to the given record.
            If hiding the summary, also hide all its descendant sub-records (but not the record itself)
         */
        {
            record.controls.expand = !record.controls.expand;   // Toggle the line-expansion status

            if (record.controls.expand)  {    // Enable showing a little inline summary of the available links
                this.get_link_summary_from_server(record);
                return;
            }

            // Hide all its descendant sub-records (but not the record itself)
            this.hide_record(record, record_index, false);
        },



        hide_record(record, record_index, hide)
        /*  Recursively hide all the descendant of the specified record;
            If hide is true, also hide the record itself
         */
        {
            console.log(`hide_record() invoked for record with index=${record_index} and record_id=${record.controls.record_id}`);

            var children = this.locate_children(record, record_index);   // By any link name/direction
            if (children.length > 0)  {
                console.log(`hide_record() : the record to hide has children; considering them first, in reverse order`);
                // Consider the children in reverse order (lowest one in the list, first)
                for (var child_n = children.length -1; child_n >= 0; child_n--)  {
                    // For each child record
                    var child_record = children[child_n];

                    var child_data = child_record.data;
                    var child_controls = child_record.controls;

                    var child_index = child_controls.pos;

                    console.log(`    considering the ${child_n}-th child (record_id=${child_id} at index pos ${child_index})`);
                    console.log(child_record);

                    var child_id = child_controls.record_id;

                    // Recursive call
                    this.hide_record(child_record, child_index, true);
                }
            }

            if (hide)  {
                // Delete 1 element from the specified index position
                console.log(`Deleting record with record_id=${record.controls.record_id}, at index pos ${record_index}`);
                this.recordset_array.splice(record_index, 1);
            }
        },



        toggle_linked_records(record, rel_name, index, dir)
        /* Toggle the display of all the "sub-records" (database nodes)
           that have a relationship by the given name
           to the specified record

           :param record:   Object with the information about the database node of interest
           :param rel_name: The name of the relationship to follow (for one hop)
           :param index:    Integer with the record position in the current listing
           :param dir:      Either "IN" or "OUT"
         */
        {
            // The given record will be referred to as "parent", because we'll be dealing
            // with its "children" (neighbor database nodes)
            const parent_record_id = record.controls.record_id;
            const parent_internal_id = record.data.internal_id;
            console.log(`In toggle_linked_records() - parent_record_id: ${parent_record_id} | parent_internal_id: ${parent_internal_id} | index: ${index} | rel_name: "${rel_name}" | dir: "${dir}"`);

            console.log(`    checking if immediate children by the relationship "${rel_name}" are present...`);
            var children = this.locate_children(record, index, rel_name, dir);


            // **** "HIDE" SCENARIO

            if (children.length > 0)  {
                // Given existing sub-records from our link name, the toggle operation is taken to be a "HIDE"
                //alert(`${children.length} link(s) already found.  No action taken`);
                console.log(`${children.length} link(s) already found; the toggle operation will be a "HIDE"...`);
                // Consider the children in reverse order (lowest one in the list, first),
                // and hide each of them (along with their descendants, if applicable)
                for (var child_n = children.length -1; child_n >= 0; child_n--)  {
                    // For each child record
                    var child_record = children[child_n];

                    var child_data = child_record.data;
                    var child_controls = child_record.controls;

                    var child_index = child_controls.pos;

                    this.hide_record(child_record, child_index, true);
                }

                return;     // We've hidden the child sub-records, and we're done!
            }


            // **** "SHOW" SCENARIO

            // Given no sub-records from our link name, the toggle operation is taken to be a "SHOW"
            console.log(`    No existing sub-records (children) found; the toggle operation will be a "SHOW"...`);

            this.get_linked_records_from_server(record, rel_name, dir);
        },



        populate_subrecords(record, rel_name, dir, new_data_arr)
        /*  Update the overall array of database records (this.recordset_array),
            to also include records newly returned by the server.
            The new objects are regarded as sub-records of the given record - neighbor
            nodes by means of the specified relationship in the given direction - and
            are to be inserted below the record, with increasing indent; they also
            get assigned auto-incremented record ID's.

            :param record:       Object
            :param rel_name:     The name of the relationship to follow (for one hop)
            :param dir:          Either "IN" or "OUT"
            :param new_data_arr: Array of objects, each containing the data of a database node
         */
        {
            const parent_record_id = record.controls.record_id;
            const n_links = new_data_arr.length;

            for (let counter = 0; counter < n_links; counter++)  {
                let new_entry = {controls: {
                                                record_id: this.next_record_id,
                                                expand: false,
                                                indent: record.controls.indent + 1,

                                                parent_record_id: parent_record_id,
                                                parent_link: rel_name,
                                                parent_dir: dir
                                            },
                                 data:
                                            new_data_arr[counter]
                                 };

                this.next_record_id += 1;   // Advance the auto-increment value
                console.log(`new_entry: record_id = ${new_entry.controls.record_id}`);
                console.log(new_entry.data);

                const i = this.locate_item(parent_record_id);

                if (i == -1)
                    alert(`Unable to locate any item with a record_id of ${parent_record_id}`);
                else  {
                    console.log(`Located parent record at index position ${i}`);
                    this.recordset_array.splice(i+1, 0, new_entry); // Insert the new entry just below its parent
                }
            }
        },



        locate_children(record, index, rel_name, dir)
        /* Given a record, and its index in the overall array of records,
           locate all its (immediate) children records - optionally requiring the given relationship.

           "Children" are defined as records below the given index position (i.e.,
           start the search just past the given index position in the overall array of records)
           that have the given record as their parent, optionally by means of the given relationship.
           One-hop relationships only.

           Return an array with all the child records, after saving their index position in their `controls` objects.

           :param record:   An object that is an element of the overall array of records this.recordset_array
           :param index:    An integer with the index of the above record in the overall array of records
           :param rel_name: [OPTIONAL] If not specified (null),
                                then children records are not restricted to that particular relationship name
           :param dir:      [OPTIONAL]
         */
        {
            const reference_id = record.controls.record_id;
            const reference_indent = record.controls.indent;
            console.log(`In locate_children(): REFERENCE record_id: ${reference_id} | index: ${index} | indent: ${reference_indent}
                        | rel_name: "${rel_name}" | dir: "${dir}"`);

            let children = [];      // Building list of all the found child records

            // Start the search just past the given index position
            //      in `this.recordset_array` (the overall array of records)
            for (var pos = index+1;  pos < this.recordset_array.length;  pos++)  {
                let record_under_consideration = this.recordset_array[pos];
                let control_data = record_under_consideration.controls;
                let parent_record_id = control_data.parent_record_id;
                let indent = control_data.indent;

                console.log(`    examining record in position ${pos}; it has indent ${indent}, id ${control_data.record_id},
                                    parent id ${parent_record_id} and parent_link ${control_data.parent_link}`);

                if (indent <= reference_indent)
                    break;      // Quit as soon as the indent is <= that of the reference record


                if (parent_record_id == reference_id)
                    // Found a match in the parentage; if a rel_name was specified, also match for that
                    if  ((rel_name == null)  || (control_data.parent_link == rel_name  &&  control_data.parent_dir == dir))  {
                        control_data.pos = pos;     // Save the array index position with the child's control data

                        console.log(`      ^--- found a child!  Pushing "record_under_consideration"`);
                        children.push(record_under_consideration);
                    }
            }

            console.log(`    Finished looping.  Number of children: ${children.length}`);

            if (children.length > 0)  {
                //console.log(`    First child:`);
                //console.log(children[0]);       // Show the 1st (0-th child), if present

                // Show the record id's of all the children
                let children_ids = [];
                for (let i=0 ;  i < children.length;  ++i)
                    children_ids.push(children[i].controls.record_id);

                console.log(`    Id's of all children: [${children_ids}]`);
            }


            //console.log("    Returning from locate_children()");

            return children;
        },



        locate_item(record_id)
        /* Attempt to locate a record with the requested id, from the overall array of records.
           If found, return its index in the array; otherwise, return -1
         */
        {
            //console.log(`Attempting to locate the record with record_id '${record_id}'`);

            const number_items = this.recordset_array.length;

            for (var i = 0; i < number_items; i++) {
                if (this.recordset_array[i].controls.record_id == record_id)
                    return i;          //  Found it
            }

            return -1;    // Didn't find it
        },




        /*
            --------------   SERVER CALLS   ----------------------------------------------------------------
         */

        lookup_fields()
        /* Invoked when the user selects, from a pulldown menu, a dbase "label" to use for the search.
           Contact the server to request all the field (property) names
           typically associated with nodes that have that dbase label
         */
        {
            const url_server_api = `/BA/api/field-names-by-class/${this.label}`;

            console.log(`Graph-database label chosen: "${this.label}"`);

            console.log(`About to contact the server at "${url_server_api}"`);

            // Initiate asynchronous contact with the server
            this.waiting = true;
            this.error = false;         // Clear any error from the previous operation
            this.status_message = "";

            ServerCommunication.contact_server(url_server_api,
                    {method: "GET", callback_fn: this.finish_lookup_fields});
        },

        finish_lookup_fields(success, server_payload, error_message, custom_data)
        /* Callback function to wrap up the action of get_data_from_server() upon getting a response from the server.
                success:        boolean indicating whether the server call succeeded
                server_payload: whatever the server returned (stripped of information about the success of the operation)
                error_message:  a string only applicable in case of failure
                custom_data:    whatever JavaScript structure, if any, was passed by the contact_server() call
        */
        {
            console.log("Finalizing the finish_lookup_fields() operation...");

            if (success)  {     // Server reported SUCCESS
                console.log("    server call was successful; it returned: ", server_payload);
                this.status_message = `Operation completed`;
                this.available_fields = server_payload;
            }
            else  {             // Server reported FAILURE
                this.error = true;
            }

            // Final wrap-up, regardless of error or success
            this.waiting = false;      // Make a note that the asynchronous operation has come to an end
        },



        submit_query()
        // Invoked when the user presses the "Submit Query" button, to perform a dbase search
        {
            const url_server_api = "/BA/api/get_filtered";

            var fields_to_search_for = "";

            if (this.key_name)
                fields_to_search_for = this.key_name;           // A manually-typed field name over-rides choices from menu
            else if (this.selected_fields)
                fields_to_search_for = this.selected_fields;    // Lower priority

            var get_obj = {label: this.label,
                           key_name: fields_to_search_for,
                           key_value: this.key_value,
                           case_sensitive: this.case_sensitive,
                           order_by: this.order_by,
                           skip: this.skip,
                           limit: this.limit};

            console.log(`About to contact the server at "${url_server_api}" .  GET object:`);
            console.log(get_obj);

            // Initiate asynchronous contact with the server
            this.waiting = true;
            this.error = false;         // Clear any error from the previous operation
            this.status_message = "";

            ServerCommunication.contact_server(url_server_api,
                    {method: "GET",
                    data_obj: get_obj,
                    json_encode_send: true,
                    callback_fn: this.finish_submit_query});
        },

        finish_submit_query(success, server_payload, error_message)
        // Callback function to wrap up the action of submit_query() upon getting a response from the server
        {
            console.log("Finalizing the submit_query() operation...");

            if (success)  {     // Server reported SUCCESS
                console.log("    server call was successful; it returned: " , server_payload);

                // server_payload is expected to be an object with 2 properties: `total_count` and `recordset`

                this.recordset_summary = server_payload.total_count;

                for (let i = 0; i < server_payload.recordset.length; i++)  {
                    let new_entry = {controls: {
                                                    record_id: this.next_record_id,

                                                    parent_record_id: null,
                                                    parent_link: null,
                                                    parent_dir: null,

                                                    expand: false,
                                                    indent: 0,
                                                    links: null
                                                },
                                     data: server_payload.recordset[i]
                                     };
                    this.next_record_id += 1;
                    //console.log(`new_entry: ${new_entry.controls}, ${new_entry.data}`);
                    Vue.set(this.recordset_array, i, new_entry);
                }

                this.status_message = `Data successfully retrieved`;
            }
            else  {             // Server reported FAILURE
                this.error = true;
                this.status_message = `FAILED retrieval of data. ${error_message}`;
            }

            // Final wrap-up, regardless of error or success
            this.waiting = false;      // Make a note that the asynchronous operation has come to an end
        },



        get_link_summary_from_server(record)
        /*  Invoked when the user clicks to expand the "Show Links" region.
            Initiate request to server, to get the list of the names/counts
            of all the Inbound and Outbound links from the given record (node)
         */
        {
            console.log(`Getting the links summary info for record id ${record.controls.record_id}`);

            const internal_id = record.data.internal_id;
            if (internal_id == null)  {
                alert("get_link_summary_from_server(): the record lacks an internal database ID.  Its links cannot be expanded");
                return;
            }
            const url_server_api = `/BA/api/get-link-summary-by-id/${internal_id}`;

            console.log(`About to contact the server at "${url_server_api}"`);

            // Initiate asynchronous contact with the server
            this.waiting = true;
            this.error = false;         // Clear any error from the previous operation
            this.status_message = "";

            ServerCommunication.contact_server(url_server_api,
                    {method: "GET",
                    callback_fn: this.finish_get_link_summary_from_server,
                    custom_data: record
                    });
        },

        finish_get_link_summary_from_server(success, server_payload, error_message, custom_data)
        /* Callback function to wrap up the action of get_link_summary_from_server() upon getting a response from the server.

            success:        boolean indicating whether the server call succeeded
            server_payload: whatever the server returned (stripped of information about the success of the operation)
            error_message:  a string only applicable in case of failure
            custom_data:    whatever JavaScript pass-thru value, if any, was passed by the contact_server() call
        */
        {
            console.log("Finalizing the get_link_summary_from_server() operation...");
            console.log(`Custom pass-thru data:`);
            console.log(custom_data);
            if (success)  {     // Server reported SUCCESS
                console.log("    server call was successful; it returned: ", server_payload);
                this.status_message = `Operation completed`;
                var record = custom_data;                   // The record object to which the retrieved link into applies
                record.controls.links = server_payload;     // Populate the record with the retrieved data
            }
            else  {             // Server reported FAILURE
                this.error = true;
                this.status_message = `FAILED operation: ${error_message}`;
            }

            // Final wrap-up, regardless of error or success
            this.waiting = false;      // Make a note that the asynchronous operation has come to an end
        },



        get_linked_records_from_server(record, rel_name, dir)
        /* Initiate request to server, to get the list of the properties
           of the data nodes linked to the specified node (record),
           by the relationship named by rel_name, in the direction requested by dir

           :param record:   Object with the record of interest
           :param rel_name: The name of the relationship to follow (for one hop)
           :param dir:      Either "IN" or "OUT"
         */
        {
            const internal_id = record.data.internal_id;

            console.log(`get_linked_records_from_server(): Getting the properties of data nodes linked to record with internal dbase ID ${internal_id} by means of the ${dir}-bound relationship '${rel_name}'`);

            const url_server_api = "/BA/api/get_records_by_link";
            const post_obj = {internal_id: internal_id, rel_name: rel_name, dir: dir};
            const my_var = [record, rel_name, dir];        // Pass-thru parameters

            console.log(`About to contact the server at "${url_server_api}" .  POST object:`);
            console.log(post_obj);

            // Initiate asynchronous contact with the server
            ServerCommunication.contact_server(url_server_api,
                        {method: "POST",
                         data_obj: post_obj,
                         json_encode_send: false,
                         callback_fn: this.finish_get_linked_records_from_server,
                         custom_data: my_var
                        });
        },

        finish_get_linked_records_from_server(success, server_payload, error_message, custom_data)
        /* Callback function to wrap up the action of get_data_from_server() upon getting a response from the server.

            success:        Boolean indicating whether the server call succeeded
            server_payload: Whatever the server returned (stripped of information about the success of the operation)
                                The server returns a JSON value.
            error_message:  A string only applicable in case of failure
            custom_data:    Whatever JavaScript pass-thru value, if any, was passed by the contact_server() call
        */
        {
            console.log("Finalizing the get_linked_records_from_server() operation...");
            console.log(`Custom pass-thru data:`);
            console.log(custom_data)
            if (success)  {     // Server reported SUCCESS
                console.log("    server call was successful; it returned: ", server_payload);
                /*  EXAMPLE of server_payload:
                        [
                            {uri: "100", internal_id: 2, name: "mushrooms pie", eval: "+"},
                            {uri: "180", internal_id: 9, name: "Margherita pie", eval: "OK"}
                        ]
                */
                this.status_message = `Operation completed`;

                const record =  custom_data[0];
                const rel_name = custom_data[1];
                const dir = custom_data[2];
                this.populate_subrecords(record, rel_name, dir, server_payload);
            }
            else  {             // Server reported FAILURE
                this.error = true;
                this.status_message = `FAILED operation: ${error_message}`;
            }

            // Final wrap-up, regardless of error or success
            this.waiting = false;      // Make a note that the asynchronous operation has come to an end

        }  // finish_get_linked_records_from_server


    } // METHODS

});
</script>


</body>
</html>